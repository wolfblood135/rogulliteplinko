<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Plinko: Cyber Rogue - Infinite</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;600;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            color: #fff;
            font-family: 'Rajdhani', sans-serif;
            overflow: hidden;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 600px;
            background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%);
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.1);
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlays */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        .currency-box {
            text-align: left;
        }

        .currency-label {
            font-size: 14px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .currency-value {
            font-size: 32px;
            font-weight: 700;
            color: #0ff;
        }

        .hud-bottom {
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            margin-bottom: 20px;
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 15px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(0, 255, 255, 0.1);
        }

        /* Bet Controls */
        .bet-controls {
            display: flex;
            gap: 5px;
            width: 100%;
            max-width: 350px;
            justify-content: center;
            margin-bottom: 5px;
            flex-wrap: wrap;
        }

        .btn-sm {
            flex: 1;
            min-width: 50px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid #444;
            color: #888;
            padding: 8px 0;
            font-size: 14px;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 4px;
        }

        .btn-sm:hover { border-color: #0ff; color: #0ff; }
        .btn-sm.active { background: rgba(0, 255, 255, 0.2); border-color: #0ff; color: #0ff; }

        /* Manual Input */
        .manual-input-container {
            display: flex;
            align-items: center;
            gap: 5px;
            width: 100%;
            max-width: 350px;
        }
        
        .manual-input {
            flex: 1;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #444;
            color: #0ff;
            padding: 8px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 16px;
            font-weight: bold;
            border-radius: 4px;
            text-align: center;
        }
        
        .manual-input:focus { outline: none; border-color: #0ff; }

        .btn {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #0ff;
            color: #0ff;
            padding: 10px 30px;
            font-size: 18px;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 700;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.2s;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
            border-radius: 4px;
        }

        .btn:hover { background: #0ff; color: #000; box-shadow: 0 0 30px rgba(0, 255, 255, 0.6); transform: scale(1.05); }
        .btn:active { transform: scale(0.95); }

        .btn-bet {
            width: 100%;
            max-width: 350px;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.1), transparent);
        }
        
        .btn-auto {
            width: 100%;
            max-width: 350px;
            border-color: #ff0;
            color: #ff0;
            margin-top: 5px;
        }
        .btn-auto.active {
            background: #ff0;
            color: #000;
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.5);
        }

        .btn-cashout {
            width: 100%;
            max-width: 350px;
            background: rgba(255, 100, 0, 0.15);
            border: 2px solid #ff6600;
            color: #ff6600;
            font-size: 16px;
        }
        .btn-cashout:hover { background: #ff6600; color: #000; box-shadow: 0 0 20px rgba(255, 100, 0, 0.6); }

        .btn-shop { border-color: #f0f; color: #f0f; box-shadow: 0 0 15px rgba(255, 0, 255, 0.2); }
        .btn-shop:hover { background: #f0f; color: #000; }

        /* Menus */
        .menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
            opacity: 1;
            transition: opacity 0.3s;
        }

        .hidden { opacity: 0; pointer-events: none; }

        h1 {
            font-size: 48px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 5px;
            margin-bottom: 10px;
            text-align: center;
        }
        h1 span { color: #0ff; }
        h1 span.rouge { color: #f0f; }

        /* Scrollable Shop */
        .shop-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
            width: 90%;
            max-width: 500px;
            margin-bottom: 20px;
            height: 55vh;
            overflow-y: auto;
            padding-right: 5px;
        }
        
        .shop-grid::-webkit-scrollbar { width: 5px; }
        .shop-grid::-webkit-scrollbar-thumb { background: #f0f; border-radius: 5px; }

        .upgrade-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #444;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 5px;
            transition: 0.2s;
        }
        .upgrade-card:hover { border-color: #f0f; background: rgba(255, 0, 255, 0.05); }

        .upgrade-info h3 { margin: 0; font-size: 16px; color: #fff; }
        .upgrade-info p { margin: 3px 0 0; font-size: 12px; color: #888; }
        
        .upgrade-btn {
            background: transparent;
            border: 1px solid #f0f;
            color: #f0f;
            padding: 5px 10px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-weight: bold;
            min-width: 90px;
            font-size: 14px;
        }
        .upgrade-btn:disabled { border-color: #444; color: #444; cursor: not-allowed; }
        .upgrade-btn:not(:disabled):hover { background: #f0f; color: white; }

        /* Floating Text */
        .floating-text {
            position: absolute;
            font-weight: bold;
            pointer-events: none;
            animation: floatUp 1s forwards ease-out;
            text-shadow: 0 0 5px currentColor;
            z-index: 10;
        }
        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-80px) scale(1.5); opacity: 0; }
        }
        
        /* Pulse Animation */
        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
            70% { box-shadow: 0 0 0 50px rgba(255, 0, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
        }
        .system-failure { animation: pulse-red 2s infinite; }

        /* AI Terminal */
        .btn-ai {
            margin-top: 5px;
            background: rgba(0, 20, 0, 0.8);
            border: 1px solid #0f0;
            color: #0f0;
            padding: 4px 10px;
            font-size: 12px;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 700;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.2);
            pointer-events: auto;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: all 0.2s;
        }
        .btn-ai:hover { background: #0f0; color: #000; box-shadow: 0 0 15px rgba(0, 255, 0, 0.6); }
        .btn-ai:disabled { opacity: 0.5; cursor: wait; }

        .ai-terminal {
            position: absolute;
            bottom: 250px; 
            left: 50%;
            transform: translateX(-50%);
            width: 85%;
            max-width: 400px;
            background: rgba(0, 10, 0, 0.95);
            border: 1px solid #0f0;
            padding: 15px;
            border-radius: 2px;
            font-family: 'VT323', monospace;
            color: #0f0;
            font-size: 18px;
            line-height: 1.2;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.1);
            display: none;
            z-index: 50;
            pointer-events: none;
            text-shadow: 0 0 2px #0f0;
        }
        .ai-terminal.active { display: block; animation: termFadeIn 0.3s ease-out; }
        .ai-header { font-size: 12px; color: #005500; border-bottom: 1px solid #005500; margin-bottom: 5px; display: flex; justify-content: space-between; }
        .typing-cursor::after { content: '█'; animation: blink 1s infinite; margin-left: 2px; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }
        @keyframes termFadeIn { from { opacity: 0; transform: translateX(-50%) translateY(10px); } to { opacity: 1; transform: translateX(-50%) translateY(0); } }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <!-- Game HUD -->
    <div id="gameUI" class="ui-layer hidden">
        <div class="hud-top">
            <div class="currency-box">
                <div class="currency-label">Run Bakiyesi</div>
                <div class="currency-value" id="currentMoneyDisplay">$100</div>
            </div>
            <div class="currency-box" style="text-align: right; display: flex; flex-direction: column; align-items: flex-end;">
                <div class="currency-label">Max Skor</div>
                <div class="currency-value" id="maxMoneyDisplay" style="color: #ff0; font-size: 24px;">$100</div>
                <button class="btn-ai" id="aiBtn" onclick="triggerAIAnalysis()">
                    <span>✨</span> AI ANALİZİ
                </button>
            </div>
        </div>
        
        <div id="aiTerminal" class="ai-terminal">
            <div class="ai-header">
                <span>SYSTEM: GHOST_AI.exe</span>
                <span>STATUS: CONNECTED</span>
            </div>
            <div id="aiContent"></div>
        </div>
        
        <div class="hud-bottom">
            <div class="bet-controls">
                <button class="btn-sm" onclick="setBetMode('min')">MIN</button>
                <button class="btn-sm" onclick="setBetMode(0.10)">%10</button>
                <button class="btn-sm" onclick="setBetMode(0.50)">%50</button>
                <button class="btn-sm" onclick="setBetMode(1.0)">MAX</button>
            </div>
            <div class="manual-input-container">
                <span style="color:#aaa; font-size:14px;">MANUEL: $</span>
                <input type="number" id="manualBetInput" class="manual-input" value="10" min="1" oninput="setManualBet(this.value)">
            </div>
            
            <div style="font-size: 14px; color: #aaa; margin-top: 5px;">TOP MALİYETİ: $<span id="betCostDisplay">10</span></div>
            
            <div style="display:flex; width:100%; max-width:350px; gap:5px;">
                <button class="btn btn-bet" id="dropBtn">TOP BIRAK</button>
                <button class="btn btn-auto" id="autoBtn" onclick="toggleAuto()">OTO-PİLOT</button>
            </div>
            
            <button class="btn btn-cashout" id="cashOutBtn" onclick="finishRunManually()">
                RUN'I BİTİR (+0 ÇİP)
            </button>
            <div style="font-size: 10px; color: #666; margin-top: 2px;">KUR: $1M = 1 ÇİP</div>
        </div>
    </div>

    <!-- Main Menu -->
    <div id="mainMenu" class="menu-overlay">
        <h1>NEON<span>PLINKO</span><br><span class="rouge">INFINITE</span></h1>
        <div style="margin-bottom: 30px; text-align: center;">
            <div class="currency-label">CYBER ÇİPLERİN</div>
            <div class="currency-value meta-currency-value" id="metaCurrencyMenu">0</div>
        </div>
        <button class="btn" id="startBtn">RUN'A BAŞLA</button>
        <br>
        <button class="btn btn-shop" id="shopBtn">KARABORSA (YÜKSELTMELER)</button>
        <div class="tutorial">
            Tıklayarak sesi açın.<br>
            Ekran tıklaması: Top Bırakır.<br>
            Hedef: 1 Milyon $ toplayıp 1 Çip'e çevirmek.
        </div>
    </div>

    <!-- Shop Menu -->
    <div id="shopMenu" class="menu-overlay hidden">
        <h1>SİBER <span>KARABORSA</span></h1>
        <div style="margin-bottom: 10px;">
            <span class="currency-label">BAKİYE: </span>
            <span class="currency-value meta-currency-value" id="shopCurrency">0</span>
        </div>
        
        <div class="shop-grid" id="shopGrid">
            <!-- Upgrades via JS -->
        </div>

        <button class="btn" id="closeShopBtn">GERİ DÖN</button>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverMenu" class="menu-overlay hidden">
        <h1 style="color: #ff4444;" class="system-failure-text" id="goTitle">SİSTEM <span>ÇÖKTÜ</span></h1>
        <div style="text-align: center; margin-bottom: 20px;">
            <p style="color: #aaa; margin: 5px;">TOPLANAN NAKİT</p>
            <div class="currency-value counting-val" id="goMaxMoney" style="color: #fff;">$0</div>
            <p style="color: #aaa; margin: 15px 0 5px 0;">KAZANILAN CYBER ÇİP</p>
            <div class="currency-value meta-currency-value counting-val" id="goMetaGain">+0</div>
        </div>
        <button class="btn btn-bet" id="restartBtn" style="display: none;">İKİNCİ ŞANS KULLAN</button>
        <br id="spacer" style="display: none;">
        <button class="btn" id="mainMenuBtn">ANA MENÜ</button>
    </div>

</div>

<script>
/**
 * AUDIO SYSTEM
 */
class SoundManager {
    constructor() {
        this.ctx = null;
        this.enabled = false;
    }

    init() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.enabled = true;
        } else if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    }

    playTone(freq, type, duration, vol = 0.1) {
        if (!this.enabled) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }

    playPegHit() { this.playTone(800 + Math.random() * 200, 'sine', 0.1, 0.05); }
    playCritHit() { this.playTone(1200 + Math.random() * 200, 'square', 0.1, 0.05); }
    playSpawn() { this.playTone(200, 'triangle', 0.1, 0.1); }
    playCoinFound() { 
        this.playTone(1500, 'sine', 0.1, 0.2); 
        setTimeout(() => this.playTone(2000, 'sine', 0.2, 0.2), 100);
    }

    playSlotHit(multiplier) {
        if (multiplier < 1) {
            this.playTone(150, 'sawtooth', 0.3, 0.1);
        } else if (multiplier < 4) {
            this.playTone(440, 'sine', 0.4, 0.1);
            setTimeout(() => this.playTone(554, 'sine', 0.4, 0.1), 50);
        } else {
            this.playTone(440, 'square', 0.1, 0.1);
            setTimeout(() => this.playTone(554, 'square', 0.1, 0.1), 100);
            setTimeout(() => this.playTone(659, 'square', 0.1, 0.1), 200);
            setTimeout(() => this.playTone(880, 'square', 0.6, 0.2), 300);
        }
    }

    playTypingSound() { if(this.enabled) this.playTone(800 + Math.random() * 400, 'square', 0.05, 0.02); }
    
    playExplosion() {
        if (!this.enabled) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.frequency.setValueAtTime(100, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.5);
    }

    playGameOver() {
        if (!this.enabled) return;
        this.playTone(300, 'sawtooth', 0.5, 0.2); 
        setTimeout(() => this.playTone(250, 'sawtooth', 0.5, 0.2), 400); 
        setTimeout(() => this.playTone(200, 'sawtooth', 0.5, 0.2), 800); 
        setTimeout(() => this.playTone(100, 'square', 1.5, 0.3), 1200); 
    }
    
    playCashOut() {
        if (!this.enabled) return;
        this.playTone(600, 'sine', 0.1, 0.1);
        setTimeout(() => this.playTone(800, 'sine', 0.1, 0.1), 100);
        setTimeout(() => this.playTone(1200, 'square', 0.4, 0.2), 200);
    }
}

const audio = new SoundManager();

/**
 * CONFIG & ECONOMY
 */
const CONFIG = {
    gravity: 0.25,
    friction: 0.99,
    restitution: 0.6,
    pegRadius: 4,
    ballRadius: 7,
    rows: 14,
    pegSpacingX: 35,
    pegSpacingY: 35
};

const ECONOMY = {
    conversionRate: 1000000 // $1M = 1 Chip
};

// Number Formatter (1K, 1M, 1B, 1T)
function formatNumber(num) {
    if (num < 1000) return Math.floor(num);
    const suffixes = ["", "K", "M", "B", "T", "Qa", "Qi"];
    const suffixNum = Math.floor(("" + Math.floor(num)).length / 3);
    let shortValue = parseFloat((suffixNum !== 0 ? (num / Math.pow(1000, suffixNum)) : num).toPrecision(3));
    if (shortValue % 1 !== 0) { shortValue = shortValue.toFixed(1); }
    return shortValue + suffixes[suffixNum];
}

/**
 * GAME STATE
 */
const GameState = {
    metaCurrency: parseInt(localStorage.getItem('cyber_rouge_chips') || '0'),
    
    // Default upgrades if none exist
    upgrades: JSON.parse(localStorage.getItem('cyber_rouge_upgrades') || JSON.stringify({
        startMoney: 0,
        multipliers: 0,
        autoDrop: 0,
        magnet: 0,
        cashback: 0,
        critBounce: 0,
        speed: 0,
        wallHit: 0,
        interest: 0,
        chipMiner: 0
    })),

    currentMoney: 100,
    maxMoneyInRun: 100,
    betCost: 10,
    betMode: 'min', 
    balls: [],
    particles: [],
    screenShake: 0,
    active: false,
    autoEnabled: false,
    lastAutoDrop: 0
};

// INFINITE SCALING UPGRADES
const UPGRADE_defs = {
    startMoney: {
        name: "Yatırım Fonu",
        desc: "Başlangıç parası artar.",
        baseCost: 5,
        costMult: 1.6, 
        effect: (lvl) => 100 + (lvl * 100 + Math.pow(lvl, 2) * 10)
    },
    multipliers: {
        name: "Hack Modülü",
        desc: "Kenar çarpanları artar (+0.2x).",
        baseCost: 10,
        costMult: 2.5,
        effect: (lvl) => lvl // used in mult calculation
    },
    autoDrop: {
        name: "Oto-Pilot",
        desc: "Otomatik atış hızı artar.",
        baseCost: 20,
        costMult: 1.8,
        effect: (lvl) => Math.max(100, 2000 - (lvl * 100)) // ms interval, min 100ms
    },
    magnet: {
        name: "Manyetik Alan",
        desc: "Topları kenarlara çeker.",
        baseCost: 50,
        costMult: 2.2,
        effect: (lvl) => lvl * 0.05 // force magnitude
    },
    cashback: {
        name: "Geri Ödeme",
        desc: "Kaybedince % iade al.",
        baseCost: 30,
        costMult: 2.0,
        effect: (lvl) => Math.min(0.5, lvl * 0.02) // max 50%
    },
    critBounce: {
        name: "Kritik Sekme",
        desc: "Pinlere çarpınca nakit verir.",
        baseCost: 40,
        costMult: 1.7,
        effect: (lvl) => lvl * 1 // $ per bounce
    },
    speed: {
        name: "Overclock",
        desc: "Oyun hızı artar.",
        baseCost: 100,
        costMult: 3.0,
        effect: (lvl) => 1 + (lvl * 0.1) // Physics multiplier
    },
    wallHit: {
        name: "Duvar Ustası",
        desc: "Duvar çarpması bonus verir.",
        baseCost: 45,
        costMult: 1.9,
        effect: (lvl) => lvl * 5 // $ per wall hit
    },
    interest: {
        name: "Faiz Lobisi",
        desc: "Her saniye paran % artar.",
        baseCost: 200,
        costMult: 2.5,
        effect: (lvl) => lvl * 0.001 // 0.1% per lvl per sec
    },
    chipMiner: {
        name: "Ethernet Madencisi",
        desc: "Top düşerken Çip bulma şansı.",
        baseCost: 500,
        costMult: 4.0,
        effect: (lvl) => lvl * 0.0005 // Chance per frame
    }
};

/**
 * GEMINI AI INTEGRATION
 */
const apiKey = ""; 

async function triggerAIAnalysis() {
    if (!apiKey) {
        showTerminalMessage("HATA: API Anahtarı Bulunamadı.");
        return;
    }

    const btn = document.getElementById('aiBtn');
    btn.disabled = true;
    btn.innerHTML = `<span>⏳</span> BAĞLANIYOR...`;
    
    showTerminalMessage("VERİ ANALİZ EDİLİYOR...", true);

    const prompt = `
        Rolün: Cyberpunk Plinko oyununda 'Ghost' isimli yapay zeka. Biraz bozuk, biraz filozof, çokça açgözlü.
        
        Durum:
        - Para: ${formatNumber(GameState.currentMoney)}
        - Kur: 1 Çip = $1M
        - Yükseltmeler: Lv${GameState.upgrades.multipliers} Hack, Lv${GameState.upgrades.magnet} Magnet.
        
        Görevin: Oyuncuya duruma uygun, 10-15 kelimelik, Türkçe, siberpunk jargonlu bir yorum yap. 
        Para azsa dalga geç, çoksa daha fazlasını iste. Sadece yorumu yaz.
    `;

    try {
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
        });

        if (!response.ok) throw new Error('Network response was not ok');
        const data = await response.json();
        const aiText = data.candidates[0].content.parts[0].text;
        showTerminalMessage(aiText);
    } catch (error) {
        console.error("AI Error:", error);
        showTerminalMessage("BAĞLANTI HATASI: GHOST ÇEVRİMDIŞI.");
    } finally {
        btn.disabled = false;
        btn.innerHTML = `<span>✨</span> AI ANALİZİ`;
    }
}

let typeWriterTimeout;
function showTerminalMessage(text, isLoading = false) {
    const term = document.getElementById('aiTerminal');
    const content = document.getElementById('aiContent');
    
    term.classList.add('active');
    term.style.display = 'block';
    content.innerHTML = '';
    content.classList.add('typing-cursor');

    if (typeWriterTimeout) clearTimeout(typeWriterTimeout);

    let i = 0;
    const speed = 30; 

    function typeWriter() {
        if (i < text.length) {
            content.innerHTML += text.charAt(i);
            i++;
            if (i % 3 === 0) audio.playTypingSound(); 
            typeWriterTimeout = setTimeout(typeWriter, speed);
        } else {
            content.classList.remove('typing-cursor');
            if (!isLoading) {
                setTimeout(() => {
                    term.classList.remove('active');
                    setTimeout(() => term.style.display = 'none', 300);
                }, 5000); 
            }
        }
    }
    typeWriter();
}

/**
 * PHYSICS CLASSES
 */
class Particle {
    constructor(x, y, color, speed) {
        this.x = x;
        this.y = y;
        this.color = color;
        const angle = Math.random() * Math.PI * 2;
        const vel = Math.random() * speed;
        this.vx = Math.cos(angle) * vel;
        this.vy = Math.sin(angle) * vel;
        this.life = 1.0;
        this.decay = 0.02 + Math.random() * 0.03;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= this.decay;
    }
    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}

class Ball {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 1;
        this.vy = 0;
        this.radius = CONFIG.ballRadius;
        this.color = `hsl(${Math.random() * 60 + 160}, 100%, 50%)`;
        this.trail = [];
        this.cost = 0; // Assigned at spawn
    }

    update(pegs, buckets) {
        // Physics Simulation Steps (Overclock)
        const steps = 1 + UPGRADE_defs.speed.effect(GameState.upgrades.speed); // 1x to ...
        
        // Only visual update trail once per frame, but physics multiple times? 
        // For simplicity, we just boost forces.
        
        // Apply forces
        this.vy += CONFIG.gravity * steps;
        this.vx *= CONFIG.friction; // friction is per frame, careful.
        this.vy *= CONFIG.friction;
        
        // Magnet Logic (Pull to Edges)
        const magnetForce = UPGRADE_defs.magnet.effect(GameState.upgrades.magnet);
        if (magnetForce > 0) {
            const centerX = document.getElementById('gameCanvas').width / 2;
            const dist = this.x - centerX;
            // Push away from center
            this.vx += (dist > 0 ? 1 : -1) * magnetForce * steps;
        }

        this.x += this.vx * steps;
        this.y += this.vy * steps;

        // Chip Mining Logic
        const chipChance = UPGRADE_defs.chipMiner.effect(GameState.upgrades.chipMiner);
        if (Math.random() < chipChance) {
            GameState.metaCurrency++;
            localStorage.setItem('cyber_rouge_chips', GameState.metaCurrency);
            showFloatingText(this.x, this.y, "+1 ÇİP", "#f0f");
            audio.playCoinFound();
        }

        const canvasWidth = document.getElementById('gameCanvas').width;
        
        // Wall Collision
        if (this.x < this.radius) {
            this.x = this.radius;
            this.vx *= -0.5;
            this.triggerWallHit();
        } else if (this.x > canvasWidth - this.radius) {
            this.x = canvasWidth - this.radius;
            this.vx *= -0.5;
            this.triggerWallHit();
        }

        this.trail.push({x: this.x, y: this.y});
        if (this.trail.length > 10) this.trail.shift();

        // Peg Collision
        for (let peg of pegs) {
            const dx = this.x - peg.x;
            const dy = this.y - peg.y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            if (dist < this.radius + CONFIG.pegRadius) {
                const angle = Math.atan2(dy, dx);
                
                // Peg Rigging (House Edge vs Magnet)
                // If Magnet is high, reduce rig
                const magnetLvl = GameState.upgrades.magnet;
                
                // Normal bounce
                const overlap = (this.radius + CONFIG.pegRadius) - dist;
                this.x += Math.cos(angle) * overlap;
                this.y += Math.sin(angle) * overlap;

                let bounceForce = 2.0;
                
                // House Edge Rigging (Push to center)
                if (magnetLvl < 5 && Math.random() < 0.6) {
                    const centerX = canvasWidth / 2;
                    const dir = (this.x < centerX) ? 1 : -1;
                    this.vx += dir * 0.5; 
                }

                this.vx += Math.cos(angle) * bounceForce;
                this.vy *= -0.5;
                
                audio.playPegHit();
                if(peg.pulse < 1) peg.pulse = 1.0; 
                
                this.vx += (Math.random() - 0.5) * 0.5;
                
                // Crit Bounce Feature
                this.triggerCritBounce();
            }
        }

        // Bucket Collision
        if (this.y > buckets[0].y) {
            const bucketWidth = CONFIG.pegSpacingX;
            const centerX = canvasWidth / 2;
            const totalBuckets = buckets.length;
            const startX = centerX - (totalBuckets * bucketWidth) / 2;
            
            let col = Math.floor((this.x - startX) / bucketWidth);
            if (col < 0) col = 0;
            if (col >= totalBuckets) col = totalBuckets - 1;

            const bucket = buckets[col];
            if (bucket) {
                this.finish(bucket.multiplier, bucket.color);
                return true; // Finished
            }
        }
        return false;
    }

    triggerWallHit() {
        const bonus = UPGRADE_defs.wallHit.effect(GameState.upgrades.wallHit);
        if (bonus > 0) {
            GameState.currentMoney += bonus;
            showFloatingText(this.x, this.y, `+$${formatNumber(bonus)}`, "#aa0");
        }
    }

    triggerCritBounce() {
        const bonus = UPGRADE_defs.critBounce.effect(GameState.upgrades.critBounce);
        if (bonus > 0 && Math.random() > 0.5) { // 50% chance per bounce if unlocked
            GameState.currentMoney += bonus;
            audio.playCritHit();
        }
    }

    finish(multiplier, color) {
        let winBase = this.cost;
        let winAmount = Math.floor(winBase * multiplier);
        
        // Cashback Logic
        if (multiplier < 1) {
            const cbRate = UPGRADE_defs.cashback.effect(GameState.upgrades.cashback);
            if (cbRate > 0) {
                const refund = Math.floor(winBase * cbRate);
                winAmount += refund;
                showFloatingText(this.x, this.y - 50, `İADE: $${formatNumber(refund)}`, "#0ff");
            }
        }

        GameState.currentMoney += winAmount;
        
        if (GameState.currentMoney > GameState.maxMoneyInRun) {
            GameState.maxMoneyInRun = GameState.currentMoney;
        }

        updateUI();
        audio.playSlotHit(multiplier);
        createExplosion(this.x, this.y, color, multiplier > 3 ? 30 : 10);
        showFloatingText(this.x, this.y - 30, `+$${formatNumber(winAmount)}`, multiplier > 1 ? '#0f0' : '#888');
        
        if (multiplier >= 10) GameState.screenShake = 20;
        else if (multiplier > 1) GameState.screenShake = 5;
    }

    draw(ctx) {
        ctx.beginPath();
        for(let i=0; i<this.trail.length; i++) {
            const p = this.trail[i];
            ctx.lineTo(p.x, p.y);
        }
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.5;
        ctx.stroke();
        ctx.globalAlpha = 1;

        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = "#fff";
        ctx.fill();
        
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.shadowBlur = 0;
    }
}

/**
 * GAME ENGINE & LOGIC
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let pegs = [];
let buckets = [];
let animationId;
let interestTimer = 0;

function resize() {
    canvas.width = document.getElementById('game-container').offsetWidth;
    canvas.height = document.getElementById('game-container').offsetHeight;
    initBoard();
}

function initBoard() {
    pegs = [];
    buckets = [];
    const startY = 100;
    const centerX = canvas.width / 2;
    
    for (let row = 0; row < CONFIG.rows; row++) {
        const cols = row + 3;
        const width = (cols - 1) * CONFIG.pegSpacingX;
        const startX = centerX - width / 2;
        for (let col = 0; col < cols; col++) {
            pegs.push({
                x: startX + col * CONFIG.pegSpacingX,
                y: startY + row * CONFIG.pegSpacingY,
                pulse: 0
            });
        }
    }

    const lastRowY = startY + (CONFIG.rows - 1) * CONFIG.pegSpacingY;
    const bucketY = lastRowY + 40;
    const bucketWidth = CONFIG.pegSpacingX;
    const totalBuckets = CONFIG.rows + 2; 
    const startX = centerX - ((totalBuckets) * bucketWidth) / 2;

    let mults = [];
    const bonus = UPGRADE_defs.multipliers.effect(GameState.upgrades.multipliers); 
    
    for(let i=0; i<totalBuckets; i++) {
        let val = 0.2; 
        if (i === 0 || i === totalBuckets - 1) val = 25.0 + bonus; 
        else if (i === 1 || i === totalBuckets - 2) val = 5.0 + (bonus * 0.2); 
        else if (i === 2 || i === totalBuckets - 3) val = 2.0; 
        else if (i === 3 || i === totalBuckets - 4) val = 1.0; 
        else val = 0.2; 
        mults.push(val);
    }

    for (let i = 0; i < totalBuckets; i++) {
        let val = mults[i];
        let color = '#fff';
        if (val < 1) color = '#f00'; 
        else if (val < 2) color = '#888'; 
        else if (val < 5) color = '#aa0'; 
        else if (val < 10) color = '#0f0'; 
        else color = '#f0f'; 

        buckets.push({
            x: startX + i * bucketWidth,
            y: bucketY,
            width: bucketWidth - 4,
            height: 30,
            multiplier: val,
            color: color
        });
    }
}

function createExplosion(x, y, color, count) {
    for (let i = 0; i < count; i++) {
        GameState.particles.push(new Particle(x, y, color, 5));
    }
}

function showFloatingText(x, y, text, color) {
    const el = document.createElement('div');
    el.className = 'floating-text';
    el.innerText = text;
    el.style.left = x + 'px';
    el.style.top = y + 'px';
    el.style.color = color;
    document.getElementById('game-container').appendChild(el);
    setTimeout(() => el.remove(), 1000);
}

function spawnBall(x, y) {
    calculateBetCost();

    if (GameState.betMode === 'min' && GameState.currentMoney < 10 && GameState.currentMoney > 0) {
        GameState.betCost = GameState.currentMoney;
    }
    if (GameState.betCost < 1 && GameState.currentMoney >= 1) {
        GameState.betCost = 1;
    }

    const ballCost = GameState.betCost;

    if (GameState.currentMoney >= ballCost && ballCost > 0) {
        GameState.currentMoney -= ballCost;
        updateUI(); 
        const b = new Ball(x, y);
        b.cost = ballCost; 
        GameState.balls.push(b);
        audio.playSpawn();
    } else {
        document.getElementById('currentMoneyDisplay').style.color = 'red';
        setTimeout(()=> document.getElementById('currentMoneyDisplay').style.color = '#0ff', 200);
        // Turn off auto if broke
        if(GameState.autoEnabled) toggleAuto();
    }
}

function calculateBetCost() {
    if (typeof GameState.betMode === 'string') {
        if(GameState.betMode === 'min') GameState.betCost = 10;
        else if(GameState.betMode === 'manual') {
            const inputVal = parseInt(document.getElementById('manualBetInput').value) || 10;
            GameState.betCost = inputVal;
        }
    } else {
        let cost = Math.floor(GameState.currentMoney * GameState.betMode);
        if (cost < 1 && GameState.currentMoney >= 1) cost = 1;
        if (GameState.betMode === 1.0) cost = GameState.currentMoney;
        GameState.betCost = cost;
    }
}

function setManualBet(val) {
    GameState.betMode = 'manual';
    document.querySelectorAll('.btn-sm').forEach(btn => btn.classList.remove('active'));
    updateUI();
}

function toggleAuto() {
    // Only allow if auto upgrade purchased (lvl > 0)
    if (GameState.upgrades.autoDrop === 0) {
        showFloatingText(canvas.width/2, canvas.height/2, "ÖNCE SATIN AL!", "red");
        return;
    }
    
    GameState.autoEnabled = !GameState.autoEnabled;
    const btn = document.getElementById('autoBtn');
    if(GameState.autoEnabled) btn.classList.add('active');
    else btn.classList.remove('active');
}

function checkGameOver() {
    if (GameState.balls.length === 0 && GameState.currentMoney < 1) {
        setTimeout(() => endRun(false), 1000);
    }
}

// Interest Logic
setInterval(() => {
    if (GameState.active && GameState.upgrades.interest > 0 && GameState.currentMoney > 0) {
        const rate = UPGRADE_defs.interest.effect(GameState.upgrades.interest);
        const gain = Math.floor(GameState.currentMoney * rate);
        if(gain > 0) {
            GameState.currentMoney += gain;
            updateUI();
        }
    }
}, 1000);

// Cash Out
window.finishRunManually = function() {
    if (!GameState.active || GameState.balls.length > 0) {
        if(GameState.balls.length > 0) showFloatingText(window.innerWidth/2, window.innerHeight/2, "TOPLAR DÜŞMELİ...", "red");
        return;
    }
    endRun(true);
};

function animateValue(id, start, end, duration, prefix = "", suffix = "") {
    const obj = document.getElementById(id);
    let startTimestamp = null;
    const step = (timestamp) => {
        if (!startTimestamp) startTimestamp = timestamp;
        const progress = Math.min((timestamp - startTimestamp) / duration, 1);
        const val = Math.floor(progress * (end - start) + start);
        obj.innerHTML = prefix + formatNumber(val) + suffix;
        if (progress < 1.0 && Math.random() < 0.2) audio.playTone(800, 'triangle', 0.05, 0.02);
        if (progress < 1) window.requestAnimationFrame(step);
    };
    window.requestAnimationFrame(step);
}

function endRun(isManual = false) {
    GameState.active = false;
    GameState.autoEnabled = false;
    document.getElementById('autoBtn').classList.remove('active');

    let reward = 0;
    let endMoney = 0;
    
    if (isManual) {
        audio.playCashOut();
        endMoney = GameState.currentMoney;
        reward = Math.floor(GameState.currentMoney / ECONOMY.conversionRate);
        document.getElementById('goTitle').innerHTML = "RUN <span>TAMAMLANDI</span>";
        document.getElementById('goTitle').style.color = "#0f0";
    } else {
        audio.playGameOver();
        endMoney = GameState.maxMoneyInRun;
        reward = 0; // Hardcore: No pity chips if you fail
        document.getElementById('goTitle').innerHTML = "SİSTEM <span>ÇÖKTÜ</span>";
        document.getElementById('goTitle').style.color = "#ff4444";
    }

    GameState.metaCurrency += reward;
    localStorage.setItem('cyber_rouge_chips', GameState.metaCurrency);

    const goMenu = document.getElementById('gameOverMenu');
    document.getElementById('gameUI').classList.add('hidden');
    goMenu.classList.remove('hidden');
    if(!isManual) goMenu.classList.add('system-failure'); 
    else goMenu.classList.remove('system-failure');

    document.getElementById('goMaxMoney').innerText = "$0";
    document.getElementById('goMetaGain').innerText = "+0 ÇİP";

    setTimeout(() => animateValue("goMaxMoney", 0, endMoney, 1500, "$"), 500);
    setTimeout(() => {
        animateValue("goMetaGain", 0, reward, 1500, "+", " ÇİP");
        createExplosion(window.innerWidth/2, window.innerHeight/2, isManual ? '#0f0' : '#f0f', 50);
    }, 2000);
}

function draw(timestamp) {
    const goMenu = document.getElementById('gameOverMenu');
    if (!GameState.active && !goMenu.classList.contains('hidden')) {
         if (goMenu.classList.contains('system-failure')) ctx.fillStyle = '#100000'; 
         else ctx.fillStyle = '#001000';
    } else {
         ctx.fillStyle = '#050505';
    }
    
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Auto Drop Logic
    if (GameState.active && GameState.autoEnabled) {
        const interval = UPGRADE_defs.autoDrop.effect(GameState.upgrades.autoDrop);
        if (timestamp - GameState.lastAutoDrop > interval) {
            spawnBall(canvas.width / 2 + (Math.random() * 20 - 10), 50);
            GameState.lastAutoDrop = timestamp;
        }
    }

    let shakeX = 0, shakeY = 0;
    if (GameState.screenShake > 0) {
        shakeX = (Math.random() - 0.5) * GameState.screenShake;
        shakeY = (Math.random() - 0.5) * GameState.screenShake;
        GameState.screenShake *= 0.9;
        if(GameState.screenShake < 0.5) GameState.screenShake = 0;
    }

    ctx.save();
    ctx.translate(shakeX, shakeY);

    for (let peg of pegs) {
        ctx.beginPath();
        ctx.arc(peg.x, peg.y, CONFIG.pegRadius, 0, Math.PI * 2);
        if (peg.pulse > 0.01) {
            ctx.fillStyle = `rgba(255, 255, 255, ${peg.pulse})`;
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#fff';
            peg.pulse *= 0.9;
        } else {
            ctx.fillStyle = '#333';
            ctx.shadowBlur = 0;
        }
        ctx.fill();
        ctx.shadowBlur = 0;
    }

    for (let b of buckets) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
        ctx.fillRect(b.x, b.y, b.width, b.height);
        
        ctx.font = 'bold 12px Rajdhani';
        ctx.textAlign = 'center';
        ctx.fillStyle = b.color;
        
        // Dynamic Multiplier Text based on upgrades
        let displayMult = b.multiplier;
        // Optimization: Don't recalc bonus every frame, but fine for canvas 2D
        
        ctx.fillText(`${displayMult.toFixed(1)}x`, b.x + b.width/2, b.y + 20);
        ctx.fillStyle = b.color;
        ctx.fillRect(b.x, b.y + b.height - 2, b.width, 2);
    }

    for (let i = GameState.balls.length - 1; i >= 0; i--) {
        let ball = GameState.balls[i];
        if (ball.active) {
            const finished = ball.update(pegs, buckets);
            ball.draw(ctx);
            if (finished) {
                GameState.balls.splice(i, 1);
                checkGameOver();
            }
        }
    }

    for (let i = GameState.particles.length - 1; i >= 0; i--) {
        let p = GameState.particles[i];
        p.update();
        p.draw(ctx);
        if (p.life <= 0) GameState.particles.splice(i, 1);
    }

    ctx.restore();
    animationId = requestAnimationFrame(draw);
}

function updateUI() {
    document.getElementById('currentMoneyDisplay').innerText = `$${formatNumber(GameState.currentMoney)}`;
    document.getElementById('maxMoneyDisplay').innerText = `$${formatNumber(GameState.maxMoneyInRun)}`;
    
    calculateBetCost();
    document.getElementById('betCostDisplay').innerText = formatNumber(GameState.betCost);

    const btn = document.getElementById('dropBtn');
    const cashBtn = document.getElementById('cashOutBtn');
    
    const potentialChips = Math.floor(GameState.currentMoney / ECONOMY.conversionRate);
    cashBtn.innerText = `RUN'I BİTİR (+${formatNumber(potentialChips)} ÇİP)`;

    if (GameState.currentMoney < GameState.betCost && GameState.betMode !== 'min' && GameState.currentMoney > 0) {
         btn.style.borderColor = 'red'; btn.style.opacity = 0.5;
    } else if (GameState.currentMoney <= 0) {
        btn.style.borderColor = 'red'; btn.style.opacity = 0.5;
        cashBtn.style.opacity = 0.5; cashBtn.style.pointerEvents = 'none';
    } else {
        btn.style.borderColor = '#0ff'; btn.style.opacity = 1;
        cashBtn.style.opacity = 1; cashBtn.style.pointerEvents = 'auto';
    }
}

window.setBetMode = function(mode) {
    GameState.betMode = mode;
    document.querySelectorAll('.btn-sm').forEach(btn => {
        btn.classList.remove('active');
        if (mode === 'min' && btn.innerText === 'MIN') btn.classList.add('active');
        if (mode === 0.10 && btn.innerText === '%10') btn.classList.add('active');
        if (mode === 0.50 && btn.innerText === '%50') btn.classList.add('active');
        if (mode === 1.0 && btn.innerText === 'MAX') btn.classList.add('active');
    });
    updateUI();
};

function updateShopUI() {
    document.getElementById('shopCurrency').innerText = formatNumber(GameState.metaCurrency);
    const grid = document.getElementById('shopGrid');
    grid.innerHTML = '';

    Object.keys(UPGRADE_defs).forEach(key => {
        const def = UPGRADE_defs[key];
        const currentLvl = GameState.upgrades[key];
        
        let cost = Math.floor(def.baseCost * Math.pow(def.costMult, currentLvl));
        
        const card = document.createElement('div');
        card.className = 'upgrade-card';
        card.innerHTML = `
            <div class="upgrade-info">
                <h3>${def.name} <span style="color:#0ff; font-size:12px;">LVL ${currentLvl}</span></h3>
                <p>${def.desc}</p>
                <div style="font-size:10px; color:#666;">Sonraki Maliyet: ${formatNumber(Math.floor(cost * def.costMult))} Çip</div>
            </div>
            <button class="upgrade-btn" onclick="buyUpgrade('${key}', ${cost})">
                ${formatNumber(cost)} ÇİP
            </button>
        `;
        grid.appendChild(card);
    });
}

window.buyUpgrade = function(key, cost) {
    if (GameState.metaCurrency >= cost) {
        GameState.metaCurrency -= cost;
        GameState.upgrades[key]++;
        localStorage.setItem('cyber_rouge_chips', GameState.metaCurrency);
        localStorage.setItem('cyber_rouge_upgrades', JSON.stringify(GameState.upgrades));
        audio.playSlotHit(10); 
        updateShopUI();
        document.getElementById('metaCurrencyMenu').innerText = formatNumber(GameState.metaCurrency);
    } else {
        audio.playSlotHit(0.2); 
    }
};

document.getElementById('startBtn').addEventListener('click', () => {
    audio.init();
    document.getElementById('mainMenu').classList.add('hidden');
    document.getElementById('gameUI').classList.remove('hidden');
    
    const startBonus = UPGRADE_defs.startMoney.effect(GameState.upgrades.startMoney);
    GameState.currentMoney = startBonus;
    GameState.maxMoneyInRun = startBonus;
    GameState.secondChanceUsed = false;
    GameState.balls = [];
    GameState.particles = [];
    GameState.active = true;
    GameState.autoEnabled = false;
    document.getElementById('autoBtn').classList.remove('active');
    
    setBetMode('min');
    initBoard();
    updateUI();
    
    cancelAnimationFrame(animationId);
    animationId = requestAnimationFrame(draw);
});

document.getElementById('shopBtn').addEventListener('click', () => {
    document.getElementById('mainMenu').classList.add('hidden');
    document.getElementById('shopMenu').classList.remove('hidden');
    updateShopUI();
});

document.getElementById('closeShopBtn').addEventListener('click', () => {
    document.getElementById('shopMenu').classList.add('hidden');
    document.getElementById('mainMenu').classList.remove('hidden');
});

document.getElementById('dropBtn').addEventListener('click', (e) => {
    e.stopPropagation(); 
    if(GameState.active) spawnBall(canvas.width / 2 + (Math.random() * 20 - 10), 50);
});

document.getElementById('game-container').addEventListener('mousedown', (e) => {
    if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'INPUT' && GameState.active && document.getElementById('gameUI').classList.contains('hidden') === false) {
        audio.init(); 
        spawnBall(canvas.width / 2 + (Math.random() * 20 - 10), 50);
    }
});

document.getElementById('mainMenuBtn').addEventListener('click', () => {
    document.getElementById('gameOverMenu').classList.add('hidden');
    document.getElementById('gameOverMenu').classList.remove('system-failure'); 
    document.getElementById('mainMenu').classList.remove('hidden');
    document.getElementById('metaCurrencyMenu').innerText = formatNumber(GameState.metaCurrency);
    cancelAnimationFrame(animationId);
});

window.addEventListener('resize', resize);
resize();
document.getElementById('metaCurrencyMenu').innerText = formatNumber(GameState.metaCurrency);

</script>
</body>
</html>
