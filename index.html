<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Plinko: Cyber Rogue - Global</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;600;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap');

        :root {
            --primary: #0ff;
            --accent: #f0f;
            --bg: #050505;
            --panel-bg: rgba(0,0,0,0.85);
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg);
            color: #fff;
            font-family: 'Rajdhani', sans-serif; /* Default Latin */
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        /* Language specific font overrides */
        body.lang-jp { font-family: 'Noto Sans JP', sans-serif; }
        body.lang-cn { font-family: 'Noto Sans SC', sans-serif; }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 600px;
            background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%);
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.1);
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlays */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            z-index: 10;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        .currency-box {
            text-align: left;
        }

        .currency-label {
            font-size: 14px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .currency-value {
            font-size: 32px;
            font-weight: 700;
            color: var(--primary);
        }

        .meta-currency-value { color: var(--accent); }

        .hud-bottom {
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            background: rgba(0,0,0,0.6);
            padding: 15px;
            border-radius: 15px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(0, 255, 255, 0.1);
            width: 100%;
            max-width: 400px;
            align-self: center;
        }

        /* Bet Controls */
        .bet-controls {
            display: flex;
            gap: 5px;
            width: 100%;
            justify-content: center;
            margin-bottom: 5px;
        }

        .btn-sm {
            flex: 1;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid #444;
            color: #888;
            padding: 8px 0;
            font-size: 14px;
            font-family: inherit;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 4px;
        }

        .btn-sm:hover { border-color: var(--primary); color: var(--primary); }
        .btn-sm.active { background: rgba(0, 255, 255, 0.2); border-color: var(--primary); color: var(--primary); }

        /* Manual Input */
        .manual-input-container {
            display: flex;
            align-items: center;
            gap: 5px;
            width: 100%;
        }
        
        .manual-input {
            flex: 1;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #444;
            color: var(--primary);
            padding: 8px;
            font-family: inherit;
            font-size: 16px;
            font-weight: bold;
            border-radius: 4px;
            text-align: center;
        }
        
        .manual-input:focus { outline: none; border-color: var(--primary); }

        .btn {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid var(--primary);
            color: var(--primary);
            padding: 15px 30px;
            font-size: 20px;
            font-family: inherit;
            font-weight: 700;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.2s;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
            border-radius: 4px;
        }

        .btn:hover { background: var(--primary); color: #000; box-shadow: 0 0 30px rgba(0, 255, 255, 0.6); transform: scale(1.05); }
        .btn:active { transform: scale(0.95); }

        .btn-bet {
            flex: 2;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.1), transparent);
        }
        
        .btn-auto {
            flex: 1;
            border-color: #ff0;
            color: #ff0;
            font-size: 16px;
            padding: 15px 10px;
        }
        .btn-auto.active {
            background: #ff0;
            color: #000;
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.5);
        }
        .btn-auto:disabled {
            border-color: #444; color: #444; cursor: not-allowed; background: rgba(0,0,0,0.2);
        }

        .btn-cashout {
            width: 100%;
            background: rgba(255, 100, 0, 0.15);
            border: 2px solid #ff6600;
            color: #ff6600;
            font-size: 18px;
            margin-top: 5px;
        }
        .btn-cashout:hover { background: #ff6600; color: #000; box-shadow: 0 0 20px rgba(255, 100, 0, 0.6); }

        .btn-shop { border-color: var(--accent); color: var(--accent); box-shadow: 0 0 15px rgba(255, 0, 255, 0.2); width: 80%; }
        .btn-shop:hover { background: var(--accent); color: #000; }

        /* Icon Buttons (Settings) */
        .icon-btn {
            background: rgba(0,0,0,0.5);
            border: 1px solid #666;
            color: #fff;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            cursor: pointer;
            pointer-events: auto;
            transition: 0.2s;
        }
        .icon-btn:hover { border-color: #fff; background: #333; }

        /* Menus */
        .menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
            opacity: 1;
            transition: opacity 0.3s;
        }

        .hidden { opacity: 0; pointer-events: none; }

        h1 {
            font-size: 48px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 5px;
            margin-bottom: 10px;
            text-align: center;
            line-height: 1;
        }
        h1 span { color: var(--primary); }
        h1 span.rouge { color: var(--accent); }

        /* Shop Grid */
        .shop-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            width: 90%;
            max-width: 500px;
            margin-bottom: 20px;
            height: 60vh;
            overflow-y: auto;
            padding-right: 5px;
        }
        
        .upgrade-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #444;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 5px;
            transition: 0.2s;
        }
        .upgrade-card:hover { border-color: var(--accent); background: rgba(255, 0, 255, 0.05); }

        .upgrade-info h3 { margin: 0; font-size: 18px; color: #fff; }
        .upgrade-info p { margin: 5px 0 0; font-size: 12px; color: #aaa; }
        
        .upgrade-btn {
            background: transparent;
            border: 1px solid var(--accent);
            color: var(--accent);
            padding: 5px 15px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            min-width: 100px;
            font-size: 14px;
        }
        .upgrade-btn:disabled { border-color: #444; color: #444; cursor: not-allowed; }
        .upgrade-btn:not(:disabled):active { background: var(--accent); color: white; }

        /* Settings Modal */
        .settings-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 80%;
            max-width: 300px;
            margin-bottom: 15px;
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
        }
        .lang-options {
            display: flex;
            gap: 10px;
        }
        .lang-btn {
            background: transparent;
            border: 1px solid #444;
            color: #666;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 14px;
        }
        .lang-btn.active { border-color: var(--primary); color: var(--primary); }

        /* Floating Text */
        .floating-text {
            position: absolute;
            font-weight: bold;
            pointer-events: none;
            animation: floatUp 1s forwards ease-out;
            text-shadow: 0 0 5px currentColor;
            z-index: 10;
        }
        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-80px) scale(1.5); opacity: 0; }
        }
        
        /* Pulse Animation */
        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
            70% { box-shadow: 0 0 0 50px rgba(255, 0, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
        }
        .system-failure { animation: pulse-red 2s infinite; }

        .tutorial {
            font-size: 14px;
            color: #888;
            margin-top: 20px;
            text-align: center;
            width: 80%;
            line-height: 1.4;
        }

        /* MOBILE WARNING OVERLAY */
        #mobileWarning {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            color: #ff4444;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }
        #mobileWarning h1 { font-size: 40px; margin-bottom: 20px; }
        #mobileWarning p { font-size: 18px; color: #fff; }

        @media (max-width: 768px) {
            #mobileWarning { display: flex; }
            #game-container { display: none; }
        }

    </style>
</head>
<body class="lang-tr">

<!-- MOBILE WARNING -->
<div id="mobileWarning">
    <h1>⚠️ PC ONLY</h1>
    <p data-t="mobile_warning">Bu oyun sadece bilgisayarda çalışır.</p>
</div>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <!-- Game HUD -->
    <div id="gameUI" class="ui-layer hidden">
        <div class="hud-top">
            <div class="currency-box">
                <div class="currency-label" data-t="run_balance">Run Bakiyesi</div>
                <div class="currency-value" id="currentMoneyDisplay">$10</div>
            </div>
            
            <div style="display: flex; gap: 10px; align-items: flex-start;">
                <div class="currency-box" style="text-align: right;">
                    <div class="currency-label" data-t="max_score">Max Skor</div>
                    <div class="currency-value" id="maxMoneyDisplay" style="color: #ff0; font-size: 24px;">$10</div>
                </div>
                <button class="icon-btn" onclick="openSettings()">⚙️</button>
            </div>
        </div>
        
        <div class="hud-bottom">
            <div class="bet-controls">
                <button class="btn-sm" onclick="setBetMode('min')">MIN</button>
                <button class="btn-sm" onclick="setBetMode(0.10)">%10</button>
                <button class="btn-sm" onclick="setBetMode(0.50)">%50</button>
                <button class="btn-sm" onclick="setBetMode(1.0)">MAX</button>
            </div>
            <div class="manual-input-container">
                <span style="color:#aaa; font-size:14px;">$</span>
                <input type="number" id="manualBetInput" class="manual-input" value="1" min="1" oninput="setManualBet(this.value)">
            </div>
            
            <div style="font-size: 12px; color: #aaa; margin-top: 5px;">
                <span data-t="top_cost">TOP MALİYETİ</span>: $<span id="betCostDisplay">1</span>
            </div>
            
            <div style="display:flex; width:100%; gap:5px;">
                <button class="btn btn-bet" id="dropBtn" data-t="btn_drop">TOP BIRAK</button>
                <button class="btn btn-auto" id="autoBtn" onclick="toggleAuto()" data-t="btn_auto">OTO</button>
            </div>
            
            <button class="btn btn-cashout" id="cashOutBtn" onclick="finishRunManually()">
                RUN'I BİTİR (+0 ÇİP)
            </button>
            <div style="font-size: 10px; color: #666; margin-top: 2px;">$1M = 1 CHIP</div>
        </div>
    </div>

    <!-- Main Menu -->
    <div id="mainMenu" class="menu-overlay">
        <h1>NEON<span>PLINKO</span><br><span class="rouge">HARDCORE</span></h1>
        <div style="margin-bottom: 20px; text-align: center;">
            <div class="currency-label" data-t="earned_chips">CYBER ÇİPLERİN</div>
            <div class="currency-value meta-currency-value" id="metaCurrencyMenu">0</div>
        </div>
        
        <button class="btn" id="startBtn" data-t="btn_start">RUN'A BAŞLA</button>
        <br>
        <button class="btn btn-shop" id="shopBtn" data-t="btn_shop">KARABORSA</button>
        <br>
        <button class="icon-btn" onclick="openSettings()" style="width: 50px; height: 50px;">⚙️</button>

        <div class="tutorial" data-t="tutorial">
            Tutorial text loading...
        </div>
    </div>

    <!-- Shop Menu -->
    <div id="shopMenu" class="menu-overlay hidden">
        <h1><span data-t="shop_title">SİBER</span> <span class="rouge" data-t="shop_title_sub">KARABORSA</span></h1>
        <div style="margin-bottom: 10px;">
            <span class="currency-label" data-t="shop_balance">BAKİYE: </span>
            <span class="currency-value meta-currency-value" id="shopCurrency">0</span>
        </div>
        
        <div class="shop-grid" id="shopGrid">
            <!-- Upgrades via JS -->
        </div>

        <button class="btn" id="closeShopBtn" data-t="btn_back">GERİ DÖN</button>
    </div>

    <!-- Settings Menu -->
    <div id="settingsMenu" class="menu-overlay hidden">
        <h1 data-t="settings_title">AYARLAR</h1>
        
        <div class="settings-row">
            <span data-t="settings_audio">SES</span>
            <button class="btn-sm" id="audioToggleBtn" onclick="toggleAudio()" style="width: 60px;">AÇIK</button>
        </div>

        <div class="settings-row" style="flex-direction: column; align-items: flex-start;">
            <div style="margin-bottom: 10px;" data-t="settings_lang">DİL / LANGUAGE</div>
            <div class="lang-options">
                <button class="lang-btn" onclick="setLanguage('tr')">TR</button>
                <button class="lang-btn" onclick="setLanguage('en')">EN</button>
                <button class="lang-btn" onclick="setLanguage('jp')">JP</button>
                <button class="lang-btn" onclick="setLanguage('cn')">CN</button>
            </div>
        </div>

        <button class="btn" onclick="closeSettings()" data-t="btn_back">GERİ DÖN</button>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverMenu" class="menu-overlay hidden">
        <h1 style="color: #ff4444;" class="system-failure-text" id="goTitle">SİSTEM <span>ÇÖKTÜ</span></h1>
        <div style="text-align: center; margin-bottom: 20px;">
            <p style="color: #aaa; margin: 5px;" data-t="collected_cash">TOPLANAN NAKİT</p>
            <div class="currency-value counting-val" id="goMaxMoney" style="color: #fff;">$0</div>
            <p style="color: #aaa; margin: 15px 0 5px 0;" data-t="earned_chips">KAZANILAN CYBER ÇİP</p>
            <div class="currency-value meta-currency-value counting-val" id="goMetaGain">+0</div>
        </div>
        <button class="btn btn-bet" id="restartBtn" style="display: none;" data-t="second_chance">İKİNCİ ŞANS</button>
        <br id="spacer" style="display: none;">
        <button class="btn" id="mainMenuBtn" data-t="main_menu">ANA MENÜ</button>
    </div>

</div>

<script>
/**
 * LOCALIZATION
 */
const I18N = {
    tr: {
        run_balance: "Run Bakiyesi", max_score: "Max Skor", top_cost: "TOP MALİYETİ",
        btn_drop: "TOP BIRAK", btn_auto: "OTO", btn_auto_lock: "KİLİTLİ",
        btn_cashout: "RUN'I BİTİR", btn_start: "RUN'A BAŞLA", btn_shop: "KARABORSA",
        btn_back: "GERİ DÖN", shop_title: "SİBER", shop_title_sub: "KARABORSA",
        shop_balance: "BAKİYE", shop_cost_next: "Sonraki Maliyet",
        game_over: "SİSTEM ÇÖKTÜ", run_complete: "RUN TAMAMLANDI",
        collected_cash: "TOPLANAN NAKİT", earned_chips: "KAZANILAN ÇİP",
        second_chance: "İKİNCİ ŞANS", main_menu: "ANA MENÜ",
        settings_title: "AYARLAR", settings_audio: "SES EFEKTLERİ", settings_lang: "DİL / LANGUAGE",
        mobile_warning: "Bu oyun sadece bilgisayarda çalışır. Lütfen bilgisayardan girin.",
        tutorial: "Tıklayarak sesi açın.<br>Ekran tıklaması: Top Bırakır.<br>Hedef: 1 Milyon $ toplayıp 1 Çip'e çevirmek.",
        upgrades: {
            startMoney: { name: "Yatırım Fonu", desc: "Başlangıç parası artar." },
            multipliers: { name: "Hack Modülü", desc: "Kenar çarpanları artar." },
            autoDrop: { name: "Oto-Pilot", desc: "Otomatik atış hızı artar." },
            cashback: { name: "Geri Ödeme", desc: "Kaybedince % iade al." },
            critBounce: { name: "Kritik Sekme", desc: "Pinlere çarpınca nakit verir." },
            speed: { name: "Overclock", desc: "Oyun hızı artar." },
            wallHit: { name: "Duvar Ustası", desc: "Duvar çarpması bonus verir." },
            interest: { name: "Faiz Lobisi", desc: "Her saniye paran % artar." },
            chipMiner: { name: "Madenci", desc: "Top düşerken Çip bulma şansı." }
        }
    },
    en: {
        run_balance: "Run Balance", max_score: "Max Score", top_cost: "BALL COST",
        btn_drop: "DROP BALL", btn_auto: "AUTO", btn_auto_lock: "LOCKED",
        btn_cashout: "END RUN", btn_start: "START RUN", btn_shop: "BLACK MARKET",
        btn_back: "BACK", shop_title: "CYBER", shop_title_sub: "MARKET",
        shop_balance: "BALANCE", shop_cost_next: "Next Cost",
        game_over: "SYSTEM FAILURE", run_complete: "RUN COMPLETE",
        collected_cash: "CASH COLLECTED", earned_chips: "CHIPS EARNED",
        second_chance: "SECOND CHANCE", main_menu: "MAIN MENU",
        settings_title: "SETTINGS", settings_audio: "AUDIO SFX", settings_lang: "LANGUAGE",
        mobile_warning: "This game does not support mobile devices. Please use a PC.",
        tutorial: "Click to enable sound.<br>Tap screen: Drop Ball.<br>Goal: Earn $1M to mint 1 Chip.",
        upgrades: {
            startMoney: { name: "Seed Fund", desc: "Increase starting cash." },
            multipliers: { name: "Hack Module", desc: "Increase edge multipliers." },
            autoDrop: { name: "Auto-Pilot", desc: "Auto drop speed increases." },
            cashback: { name: "Cashback", desc: "Refund % on loss." },
            critBounce: { name: "Crit Bounce", desc: "Pins yield cash on hit." },
            speed: { name: "Overclock", desc: "Game speed increases." },
            wallHit: { name: "Wall Master", desc: "Bonus on wall hits." },
            interest: { name: "Compound Interest", desc: "% Cash growth per sec." },
            chipMiner: { name: "Miner", desc: "Chance to find Chips dropping." }
        }
    },
    jp: {
        run_balance: "現在の資金", max_score: "最大スコア", top_cost: "ボールコスト",
        btn_drop: "ドロップ", btn_auto: "自動", btn_auto_lock: "ロック",
        btn_cashout: "利益確定", btn_start: "実行開始", btn_shop: "闇市",
        btn_back: "戻る", shop_title: "サイバー", shop_title_sub: "闇市",
        shop_balance: "残高", shop_cost_next: "次のコスト",
        game_over: "システム障害", run_complete: "実行完了",
        collected_cash: "集めた現金", earned_chips: "獲得チップ",
        second_chance: "セカンドチャンス", main_menu: "メインメニュー",
        settings_title: "設定", settings_audio: "効果音", settings_lang: "言語",
        mobile_warning: "このゲームはモバイルデバイスに対応していません。PCを使用してください。",
        tutorial: "クリックして音声を有効化。<br>画面タップ: ボール投下。<br>目標: 100万ドルで1チップ獲得。",
        upgrades: {
            startMoney: { name: "初期資金", desc: "開始時の資金が増加。" },
            multipliers: { name: "ハック", desc: "端の倍率が増加。" },
            autoDrop: { name: "自動操縦", desc: "自動投下速度が増加。" },
            cashback: { name: "キャッシュバック", desc: "損失時に一部返金。" },
            critBounce: { name: "クリティカル", desc: "ピンヒットで現金獲得。" },
            speed: { name: "オーバークロック", desc: "ゲーム速度が増加。" },
            wallHit: { name: "壁マスター", desc: "壁ヒットでボーナス。" },
            interest: { name: "複利", desc: "毎秒資金が%増加。" },
            chipMiner: { name: "マイナー", desc: "チップ発見のチャンス。" }
        }
    },
    cn: {
        run_balance: "当前资金", max_score: "最高分", top_cost: "球成本",
        btn_drop: "投放", btn_auto: "自动", btn_auto_lock: "锁定",
        btn_cashout: "结束运行", btn_start: "开始运行", btn_shop: "黑市",
        btn_back: "返回", shop_title: "赛博", shop_title_sub: "黑市",
        shop_balance: "余额", shop_cost_next: "下一级成本",
        game_over: "系统崩溃", run_complete: "运行完成",
        collected_cash: "收集现金", earned_chips: "获得芯片",
        second_chance: "第二次机会", main_menu: "主菜单",
        settings_title: "设置", settings_audio: "音效", settings_lang: "语言",
        mobile_warning: "此游戏不支持移动设备。请使用电脑。",
        tutorial: "点击开启声音。<br>点击屏幕：投放球。<br>目标：赚取100万以获得1个芯片。",
        upgrades: {
            startMoney: { name: "启动资金", desc: "增加初始资金。" },
            multipliers: { name: "黑客模块", desc: "增加边缘倍率。" },
            autoDrop: { name: "自动驾驶", desc: "自动投放速度增加。" },
            cashback: { name: "返现", desc: "亏损时返还百分比。" },
            critBounce: { name: "暴击弹跳", desc: "撞击钉子获得现金。" },
            speed: { name: "超频", desc: "游戏速度增加。" },
            wallHit: { name: "墙壁大师", desc: "撞墙获得奖励。" },
            interest: { name: "复利", desc: "每秒资金百分比增长。" },
            chipMiner: { name: "矿工", desc: "掉落时发现芯片的几率。" }
        }
    }
};

/**
 * AUDIO SYSTEM
 */
class SoundManager {
    constructor() {
        this.ctx = null;
        this.enabled = true; // Controlled by settings
    }

    init() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        } else if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    }

    playTone(freq, type, duration, vol = 0.1) {
        if (!this.enabled || !this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }

    playPegHit() { this.playTone(800 + Math.random() * 200, 'sine', 0.1, 0.05); }
    playCritHit() { this.playTone(1200 + Math.random() * 200, 'square', 0.1, 0.05); }
    playSpawn() { this.playTone(200, 'triangle', 0.1, 0.1); }
    playCoinFound() { 
        this.playTone(1500, 'sine', 0.1, 0.2); 
        setTimeout(() => this.playTone(2000, 'sine', 0.2, 0.2), 100);
    }

    playSlotHit(multiplier) {
        if (multiplier < 1) {
            this.playTone(150, 'sawtooth', 0.3, 0.1);
        } else if (multiplier < 4) {
            this.playTone(440, 'sine', 0.4, 0.1);
            setTimeout(() => this.playTone(554, 'sine', 0.4, 0.1), 50);
        } else {
            this.playTone(440, 'square', 0.1, 0.1);
            setTimeout(() => this.playTone(554, 'square', 0.1, 0.1), 100);
            setTimeout(() => this.playTone(659, 'square', 0.1, 0.1), 200);
            setTimeout(() => this.playTone(880, 'square', 0.6, 0.2), 300);
        }
    }

    playUpgradeBuy(streak) {
        if (!this.enabled) return;
        const freq = Math.min(1500, 300 + (streak * 70));
        this.playTone(freq, 'triangle', 0.08, 0.15);
    }
    
    playExplosion() {
        if (!this.enabled || !this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.frequency.setValueAtTime(100, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.5);
    }

    playGameOver() {
        if (!this.enabled) return;
        this.playTone(300, 'sawtooth', 0.5, 0.2); 
        setTimeout(() => this.playTone(250, 'sawtooth', 0.5, 0.2), 400); 
        setTimeout(() => this.playTone(200, 'sawtooth', 0.5, 0.2), 800); 
        setTimeout(() => this.playTone(100, 'square', 1.5, 0.3), 1200); 
    }
    
    playCashOut() {
        if (!this.enabled) return;
        this.playTone(600, 'sine', 0.1, 0.1);
        setTimeout(() => this.playTone(800, 'sine', 0.1, 0.1), 100);
        setTimeout(() => this.playTone(1200, 'square', 0.4, 0.2), 200);
    }
}

const audio = new SoundManager();

/**
 * CONFIG & ECONOMY
 */
const CONFIG = {
    gravity: 0.25,
    friction: 0.99,
    restitution: 0.6,
    pegRadius: 4,
    ballRadius: 7, // Reverted to 7
    rows: 14,
    pegSpacingX: 35,
    pegSpacingY: 35
};

const ECONOMY = {
    conversionRate: 1000000 // $1M = 1 Chip
};

function formatNumber(num) {
    if (num < 1000) return Math.floor(num);
    const suffixes = ["", "K", "M", "B", "T", "Qa", "Qi"];
    const suffixNum = Math.floor(("" + Math.floor(num)).length / 3);
    let shortValue = parseFloat((suffixNum !== 0 ? (num / Math.pow(1000, suffixNum)) : num).toPrecision(3));
    if (shortValue % 1 !== 0) { shortValue = shortValue.toFixed(1); }
    return shortValue + suffixes[suffixNum];
}

/**
 * GAME STATE
 */
const GameState = {
    metaCurrency: parseInt(localStorage.getItem('cyber_rouge_chips') || '0'),
    settings: JSON.parse(localStorage.getItem('cyber_rouge_settings') || JSON.stringify({
        audio: true,
        lang: 'tr'
    })),
    
    upgrades: JSON.parse(localStorage.getItem('cyber_rouge_upgrades') || JSON.stringify({
        startMoney: 0,
        multipliers: 0,
        autoDrop: 0,
        cashback: 0,
        critBounce: 0,
        speed: 0,
        wallHit: 0,
        interest: 0,
        chipMiner: 0
    })),

    currentMoney: 10, 
    maxMoneyInRun: 10,
    betCost: 1, 
    betMode: 'min', 
    balls: [],
    particles: [],
    screenShake: 0,
    active: false,
    autoEnabled: false,
    lastAutoDrop: 0
};

// UPGRADES
const UPGRADE_defs = {
    startMoney: { baseCost: 5, costMult: 1.6, effect: (lvl) => 10 + (lvl * 10 + Math.pow(lvl, 2) * 5) },
    multipliers: { baseCost: 10, costMult: 2.5, effect: (lvl) => lvl },
    autoDrop: { baseCost: 20, costMult: 1.8, effect: (lvl) => Math.max(100, 2000 - (lvl * 100)) },
    cashback: { baseCost: 30, costMult: 2.0, effect: (lvl) => Math.min(0.5, lvl * 0.02) },
    critBounce: { baseCost: 40, costMult: 1.7, effect: (lvl) => lvl * 1 },
    speed: { baseCost: 100, costMult: 3.0, effect: (lvl) => 1 + (lvl * 0.1) },
    wallHit: { baseCost: 45, costMult: 1.9, effect: (lvl) => lvl * 5 },
    interest: { baseCost: 200, costMult: 2.5, effect: (lvl) => lvl * 0.001 },
    chipMiner: { baseCost: 500, costMult: 4.0, effect: (lvl) => lvl * 0.0005 }
};

/**
 * LOGIC - I18N & Settings
 */
function t(key) {
    return I18N[GameState.settings.lang][key] || key;
}

function updateLanguage() {
    const lang = GameState.settings.lang;
    document.body.className = `lang-${lang}`;
    
    // Update elements with data-t attribute
    document.querySelectorAll('[data-t]').forEach(el => {
        el.innerHTML = t(el.getAttribute('data-t'));
    });

    // Update dynamic text
    const btnCash = document.getElementById('cashOutBtn');
    const chips = Math.floor(GameState.currentMoney / ECONOMY.conversionRate);
    btnCash.innerText = `${t('btn_cashout')} (+${formatNumber(chips)} ${t('earned_chips').split(' ').pop()})`;

    const btnAuto = document.getElementById('autoBtn');
    if (GameState.upgrades.autoDrop === 0) btnAuto.innerText = t('btn_auto_lock');
    else btnAuto.innerText = t('btn_auto');

    updateShopUI(); // Refresh shop text
    
    // Update language buttons in settings
    document.querySelectorAll('.lang-btn').forEach(btn => {
        btn.classList.toggle('active', btn.innerText.toLowerCase() === lang);
    });
}

function openSettings() {
    document.getElementById('settingsMenu').classList.remove('hidden');
    // Sync UI
    const audioBtn = document.getElementById('audioToggleBtn');
    audioBtn.innerText = GameState.settings.audio ? "ON" : "OFF";
    audioBtn.style.color = GameState.settings.audio ? "#0ff" : "#666";
    audioBtn.style.borderColor = GameState.settings.audio ? "#0ff" : "#666";
}

function closeSettings() {
    document.getElementById('settingsMenu').classList.add('hidden');
}

function toggleAudio() {
    GameState.settings.audio = !GameState.settings.audio;
    audio.enabled = GameState.settings.audio;
    localStorage.setItem('cyber_rouge_settings', JSON.stringify(GameState.settings));
    
    const audioBtn = document.getElementById('audioToggleBtn');
    audioBtn.innerText = GameState.settings.audio ? "ON" : "OFF";
    audioBtn.style.color = GameState.settings.audio ? "#0ff" : "#666";
    audioBtn.style.borderColor = GameState.settings.audio ? "#0ff" : "#666";
}

function setLanguage(lang) {
    GameState.settings.lang = lang;
    localStorage.setItem('cyber_rouge_settings', JSON.stringify(GameState.settings));
    updateLanguage();
}

/**
 * PHYSICS CLASSES
 */
class Particle {
    constructor(x, y, color, speed) {
        this.x = x; this.y = y; this.color = color;
        const angle = Math.random() * Math.PI * 2;
        const vel = Math.random() * speed;
        this.vx = Math.cos(angle) * vel;
        this.vy = Math.sin(angle) * vel;
        this.life = 1.0;
        this.decay = 0.02 + Math.random() * 0.03;
    }
    update() {
        this.x += this.vx; this.y += this.vy; this.life -= this.decay;
    }
    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}

class Ball {
    constructor(x, y) {
        this.x = x; this.y = y;
        this.vx = (Math.random() - 0.5) * 1;
        this.vy = 0;
        this.radius = CONFIG.ballRadius;
        this.color = `hsl(${Math.random() * 60 + 160}, 100%, 50%)`;
        this.trail = [];
        this.cost = 0; 
        this.active = true;
    }

    update(pegs, buckets) {
        const steps = 1 + UPGRADE_defs.speed.effect(GameState.upgrades.speed); 
        this.vy += CONFIG.gravity * steps;
        this.vx *= CONFIG.friction;
        this.vy *= CONFIG.friction;
        this.x += this.vx * steps;
        this.y += this.vy * steps;

        // Mining
        const chipChance = UPGRADE_defs.chipMiner.effect(GameState.upgrades.chipMiner);
        if (Math.random() < chipChance) {
            GameState.metaCurrency++;
            localStorage.setItem('cyber_rouge_chips', GameState.metaCurrency);
            showFloatingText(this.x, this.y, "+1 CHIP", "#f0f");
            audio.playCoinFound();
        }

        // Walls
        const canvasWidth = document.getElementById('gameCanvas').width;
        if (this.x < this.radius) {
            this.x = this.radius; this.vx *= -0.5; this.triggerWallHit();
        } else if (this.x > canvasWidth - this.radius) {
            this.x = canvasWidth - this.radius; this.vx *= -0.5; this.triggerWallHit();
        }

        this.trail.push({x: this.x, y: this.y});
        if (this.trail.length > 8) this.trail.shift();

        // Pegs
        for (let peg of pegs) {
            const dx = this.x - peg.x; const dy = this.y - peg.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < this.radius + CONFIG.pegRadius) {
                const angle = Math.atan2(dy, dx);
                const overlap = (this.radius + CONFIG.pegRadius) - dist;
                this.x += Math.cos(angle) * overlap;
                this.y += Math.sin(angle) * overlap;
                let bounceForce = 2.0;
                
                // Rigging
                if (Math.random() < 0.6) {
                    const centerX = canvasWidth / 2;
                    const dir = (this.x < centerX) ? 1 : -1;
                    this.vx += dir * 0.5; 
                }

                this.vx += Math.cos(angle) * bounceForce;
                this.vy *= -0.5;
                audio.playPegHit();
                if(peg.pulse < 1) peg.pulse = 1.0; 
                this.vx += (Math.random() - 0.5) * 0.5;
                this.triggerCritBounce();
            }
        }

        // Buckets
        if (this.y > buckets[0].y) {
            const bucketWidth = CONFIG.pegSpacingX;
            const centerX = canvasWidth / 2;
            const totalBuckets = buckets.length;
            const startX = centerX - (totalBuckets * bucketWidth) / 2;
            let col = Math.floor((this.x - startX) / bucketWidth);
            if (col < 0) col = 0; if (col >= totalBuckets) col = totalBuckets - 1;
            const bucket = buckets[col];
            if (bucket) {
                this.finish(bucket.multiplier, bucket.color);
                return true; 
            }
        }
        return false;
    }

    triggerWallHit() {
        const bonus = UPGRADE_defs.wallHit.effect(GameState.upgrades.wallHit);
        if (bonus > 0) {
            GameState.currentMoney += bonus;
            showFloatingText(this.x, this.y, `+$${formatNumber(bonus)}`, "#aa0");
        }
    }

    triggerCritBounce() {
        const bonus = UPGRADE_defs.critBounce.effect(GameState.upgrades.critBounce);
        if (bonus > 0 && Math.random() > 0.5) { 
            GameState.currentMoney += bonus;
            audio.playCritHit();
        }
    }

    finish(multiplier, color) {
        let winBase = this.cost;
        let winAmount = Math.floor(winBase * multiplier);
        if (multiplier < 1) {
            const cbRate = UPGRADE_defs.cashback.effect(GameState.upgrades.cashback);
            if (cbRate > 0) {
                const refund = Math.floor(winBase * cbRate);
                winAmount += refund;
                showFloatingText(this.x, this.y - 50, `+${formatNumber(refund)}`, "#0ff");
            }
        }
        GameState.currentMoney += winAmount;
        if (GameState.currentMoney > GameState.maxMoneyInRun) GameState.maxMoneyInRun = GameState.currentMoney;
        updateUI();
        audio.playSlotHit(multiplier);
        createExplosion(this.x, this.y, color, multiplier > 3 ? 30 : 10);
        showFloatingText(this.x, this.y - 30, `+$${formatNumber(winAmount)}`, multiplier > 1 ? '#0f0' : '#888');
        
        if (multiplier >= 10) GameState.screenShake = 20;
        else if (multiplier > 1) GameState.screenShake = 5;
    }

    draw(ctx) {
        ctx.beginPath();
        for(let i=0; i<this.trail.length; i++) {
            const p = this.trail[i];
            ctx.lineTo(p.x, p.y);
        }
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.5;
        ctx.stroke();
        ctx.globalAlpha = 1;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = "#fff";
        ctx.fill();
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.shadowBlur = 0;
    }
}

/**
 * GAME ENGINE
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let pegs = [];
let buckets = [];
let animationId;

function resize() {
    canvas.width = document.getElementById('game-container').offsetWidth;
    canvas.height = document.getElementById('game-container').offsetHeight;
    initBoard();
}

function initBoard() {
    pegs = [];
    buckets = [];
    const startY = 100; // Fixed top margin
    const centerX = canvas.width / 2;
    
    // Scale board back to normal logic, no mobile scaling
    const spacingX = CONFIG.pegSpacingX;
    const spacingY = CONFIG.pegSpacingY;

    for (let row = 0; row < CONFIG.rows; row++) {
        const cols = row + 3;
        const width = (cols - 1) * spacingX;
        const startX = centerX - width / 2;
        for (let col = 0; col < cols; col++) {
            pegs.push({
                x: startX + col * spacingX,
                y: startY + row * spacingY,
                pulse: 0
            });
        }
    }

    const lastRowY = startY + (CONFIG.rows - 1) * spacingY;
    const bucketY = lastRowY + 40;
    const bucketWidth = spacingX;
    const totalBuckets = CONFIG.rows + 2; 
    const startX = centerX - ((totalBuckets) * bucketWidth) / 2;

    let mults = [];
    const bonus = UPGRADE_defs.multipliers.effect(GameState.upgrades.multipliers); 
    
    for(let i=0; i<totalBuckets; i++) {
        let val = 0.1; 
        if (i === 0 || i === totalBuckets - 1) val = 10.0 + (bonus * 2); 
        else if (i === 1 || i === totalBuckets - 2) val = 2.0 + (bonus * 0.5); 
        else if (i === 2 || i === totalBuckets - 3) val = 1.0; 
        else if (i === 3 || i === totalBuckets - 4) val = 0.3; 
        else val = 0.1; 
        mults.push(val);
    }

    for (let i = 0; i < totalBuckets; i++) {
        let val = mults[i];
        let color = '#fff';
        if (val < 1) color = '#f00'; 
        else if (val < 2) color = '#888'; 
        else if (val < 5) color = '#aa0'; 
        else if (val < 15) color = '#0f0'; 
        else color = '#f0f'; 

        buckets.push({
            x: startX + i * bucketWidth,
            y: bucketY,
            width: bucketWidth - 2,
            height: 30,
            multiplier: val,
            color: color
        });
    }
}

function createExplosion(x, y, color, count) {
    for (let i = 0; i < count; i++) {
        GameState.particles.push(new Particle(x, y, color, 5));
    }
}

function showFloatingText(x, y, text, color) {
    const el = document.createElement('div');
    el.className = 'floating-text';
    el.innerText = text;
    el.style.left = x + 'px';
    el.style.top = y + 'px';
    el.style.color = color;
    document.getElementById('game-container').appendChild(el);
    setTimeout(() => el.remove(), 1000);
}

function spawnBall(x, y) {
    calculateBetCost();
    if (GameState.currentMoney > 0 && GameState.currentMoney < GameState.betCost) GameState.betCost = GameState.currentMoney;
    if (GameState.betCost < 1 && GameState.currentMoney >= 1) GameState.betCost = 1;

    const ballCost = GameState.betCost;
    if (GameState.currentMoney >= ballCost && ballCost > 0) {
        GameState.currentMoney -= ballCost;
        updateUI(); 
        const b = new Ball(x, y);
        b.cost = ballCost; 
        GameState.balls.push(b);
        audio.playSpawn();
    } else {
        document.getElementById('currentMoneyDisplay').style.color = 'red';
        setTimeout(()=> document.getElementById('currentMoneyDisplay').style.color = '#0ff', 200);
        if(GameState.autoEnabled) toggleAuto();
    }
}

function calculateBetCost() {
    if (typeof GameState.betMode === 'string') {
        if(GameState.betMode === 'min') GameState.betCost = 1;
        else if(GameState.betMode === 'manual') {
            const inputVal = parseInt(document.getElementById('manualBetInput').value) || 1;
            GameState.betCost = inputVal;
        }
    } else {
        let cost = Math.floor(GameState.currentMoney * GameState.betMode);
        if (cost < 1 && GameState.currentMoney >= 1) cost = 1;
        if (GameState.betMode === 1.0) cost = GameState.currentMoney;
        GameState.betCost = cost;
    }
}

function setManualBet(val) {
    GameState.betMode = 'manual';
    document.querySelectorAll('.btn-sm').forEach(btn => btn.classList.remove('active'));
    updateUI();
}

function toggleAuto() {
    if (GameState.upgrades.autoDrop === 0) {
        showFloatingText(canvas.width/2, canvas.height/2, t('btn_auto_lock'), "red");
        return;
    }
    GameState.autoEnabled = !GameState.autoEnabled;
    updateUI();
}

function checkGameOver() {
    if (GameState.balls.length === 0 && GameState.currentMoney < 1) setTimeout(() => endRun(false), 1000);
}

setInterval(() => {
    if (GameState.active && GameState.upgrades.interest > 0 && GameState.currentMoney > 0) {
        const rate = UPGRADE_defs.interest.effect(GameState.upgrades.interest);
        const gain = Math.floor(GameState.currentMoney * rate);
        if(gain > 0) {
            GameState.currentMoney += gain;
            updateUI();
        }
    }
}, 1000);

window.finishRunManually = function() {
    if (!GameState.active || GameState.balls.length > 0) {
        // Simple visual feedback
        return;
    }
    endRun(true);
};

function animateValue(id, start, end, duration, prefix = "", suffix = "") {
    const obj = document.getElementById(id);
    let startTimestamp = null;
    const step = (timestamp) => {
        if (!startTimestamp) startTimestamp = timestamp;
        const progress = Math.min((timestamp - startTimestamp) / duration, 1);
        const val = Math.floor(progress * (end - start) + start);
        obj.innerHTML = prefix + formatNumber(val) + suffix;
        if (progress < 1.0 && Math.random() < 0.2) audio.playTone(800, 'triangle', 0.05, 0.02);
        if (progress < 1) window.requestAnimationFrame(step);
    };
    window.requestAnimationFrame(step);
}

function endRun(isManual = false) {
    GameState.active = false;
    GameState.autoEnabled = false;
    updateUI();

    let reward = 0;
    let endMoney = 0;
    
    if (isManual) {
        audio.playCashOut();
        endMoney = GameState.currentMoney;
        reward = Math.floor(GameState.currentMoney / ECONOMY.conversionRate);
        document.getElementById('goTitle').innerHTML = `${t('run_complete').split(' ')[0]} <span>${t('run_complete').split(' ')[1]}</span>`;
        document.getElementById('goTitle').style.color = "#0f0";
    } else {
        audio.playGameOver();
        endMoney = GameState.maxMoneyInRun;
        reward = 0; 
        document.getElementById('goTitle').innerHTML = `${t('game_over').split(' ')[0]} <span>${t('game_over').split(' ')[1]}</span>`;
        document.getElementById('goTitle').style.color = "#ff4444";
    }

    GameState.metaCurrency += reward;
    localStorage.setItem('cyber_rouge_chips', GameState.metaCurrency);

    const goMenu = document.getElementById('gameOverMenu');
    document.getElementById('gameUI').classList.add('hidden');
    goMenu.classList.remove('hidden');
    if(!isManual) goMenu.classList.add('system-failure'); 
    else goMenu.classList.remove('system-failure');

    document.getElementById('goMaxMoney').innerText = "$0";
    document.getElementById('goMetaGain').innerText = "+0 " + t('earned_chips').split(' ').pop();

    setTimeout(() => animateValue("goMaxMoney", 0, endMoney, 1500, "$"), 500);
    setTimeout(() => {
        animateValue("goMetaGain", 0, reward, 1500, "+", " " + t('earned_chips').split(' ').pop());
        createExplosion(window.innerWidth/2, window.innerHeight/2, isManual ? '#0f0' : '#f0f', 50);
    }, 2000);
}

function draw(timestamp) {
    const goMenu = document.getElementById('gameOverMenu');
    if (!GameState.active && !goMenu.classList.contains('hidden')) {
         if (goMenu.classList.contains('system-failure')) ctx.fillStyle = '#100000'; 
         else ctx.fillStyle = '#001000';
    } else {
         ctx.fillStyle = '#050505';
    }
    
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (GameState.active && GameState.autoEnabled) {
        const interval = UPGRADE_defs.autoDrop.effect(GameState.upgrades.autoDrop);
        if (timestamp - GameState.lastAutoDrop > interval) {
            spawnBall(canvas.width / 2 + (Math.random() * 20 - 10), 50);
            GameState.lastAutoDrop = timestamp;
        }
    }

    let shakeX = 0, shakeY = 0;
    if (GameState.screenShake > 0) {
        shakeX = (Math.random() - 0.5) * GameState.screenShake;
        shakeY = (Math.random() - 0.5) * GameState.screenShake;
        GameState.screenShake *= 0.9;
        if(GameState.screenShake < 0.5) GameState.screenShake = 0;
    }

    ctx.save();
    ctx.translate(shakeX, shakeY);

    for (let peg of pegs) {
        ctx.beginPath();
        ctx.arc(peg.x, peg.y, CONFIG.pegRadius, 0, Math.PI * 2);
        if (peg.pulse > 0.01) {
            ctx.fillStyle = `rgba(255, 255, 255, ${peg.pulse})`;
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#fff';
            peg.pulse *= 0.9;
        } else {
            ctx.fillStyle = '#333';
            ctx.shadowBlur = 0;
        }
        ctx.fill();
        ctx.shadowBlur = 0;
    }

    for (let b of buckets) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
        ctx.fillRect(b.x, b.y, b.width, b.height);
        
        ctx.font = 'bold 12px Rajdhani';
        ctx.textAlign = 'center';
        ctx.fillStyle = b.color;
        
        let displayMult = b.multiplier;
        ctx.fillText(`${displayMult.toFixed(1)}x`, b.x + b.width/2, b.y + 20);
        ctx.fillStyle = b.color;
        ctx.fillRect(b.x, b.y + b.height - 2, b.width, 2);
    }

    for (let i = GameState.balls.length - 1; i >= 0; i--) {
        let ball = GameState.balls[i];
        if (ball.active) {
            const finished = ball.update(pegs, buckets);
            ball.draw(ctx);
            if (finished) {
                GameState.balls.splice(i, 1);
                checkGameOver();
            }
        }
    }

    for (let i = GameState.particles.length - 1; i >= 0; i--) {
        let p = GameState.particles[i];
        p.update();
        p.draw(ctx);
        if (p.life <= 0) GameState.particles.splice(i, 1);
    }

    ctx.restore();
    animationId = requestAnimationFrame(draw);
}

function updateUI() {
    document.getElementById('currentMoneyDisplay').innerText = `$${formatNumber(GameState.currentMoney)}`;
    document.getElementById('maxMoneyDisplay').innerText = `$${formatNumber(GameState.maxMoneyInRun)}`;
    
    calculateBetCost();
    document.getElementById('betCostDisplay').innerText = formatNumber(GameState.betCost);

    const btn = document.getElementById('dropBtn');
    const cashBtn = document.getElementById('cashOutBtn');
    const autoBtn = document.getElementById('autoBtn');
    
    const chipText = t('earned_chips').split(' ').pop(); // Just "CHIPS"
    const potentialChips = Math.floor(GameState.currentMoney / ECONOMY.conversionRate);
    cashBtn.innerText = `${t('btn_cashout')} (+${formatNumber(potentialChips)} ${chipText})`;

    if (GameState.currentMoney < 1) {
        btn.style.borderColor = 'red'; btn.style.opacity = 0.5;
        cashBtn.style.opacity = 0.5; cashBtn.style.pointerEvents = 'none';
    } else {
        btn.style.borderColor = '#0ff'; btn.style.opacity = 1;
        cashBtn.style.opacity = 1; cashBtn.style.pointerEvents = 'auto';
    }

    if (GameState.upgrades.autoDrop === 0) {
        autoBtn.innerText = t('btn_auto_lock');
        autoBtn.disabled = true;
    } else {
        autoBtn.innerText = t('btn_auto');
        autoBtn.disabled = false;
        if(GameState.autoEnabled) autoBtn.classList.add('active');
        else autoBtn.classList.remove('active');
    }
}

window.setBetMode = function(mode) {
    GameState.betMode = mode;
    document.querySelectorAll('.btn-sm').forEach(btn => {
        btn.classList.remove('active');
        if (mode === 'min' && btn.innerText === 'MIN') btn.classList.add('active');
        if (mode === 0.10 && btn.innerText === '%10') btn.classList.add('active');
        if (mode === 0.50 && btn.innerText === '%50') btn.classList.add('active');
        if (mode === 1.0 && btn.innerText === 'MAX') btn.classList.add('active');
    });
    updateUI();
};

function updateShopUI() {
    document.getElementById('shopCurrency').innerText = formatNumber(GameState.metaCurrency);
    const grid = document.getElementById('shopGrid');
    grid.innerHTML = '';

    const langData = I18N[GameState.settings.lang].upgrades;

    Object.keys(UPGRADE_defs).forEach(key => {
        const def = UPGRADE_defs[key];
        const currentLvl = GameState.upgrades[key];
        const local = langData[key] || {name: key, desc: ""};
        
        const card = document.createElement('div');
        card.className = 'upgrade-card';
        
        let cost = Math.floor(def.baseCost * Math.pow(def.costMult, currentLvl));
        
        card.innerHTML = `
            <div class="upgrade-info">
                <h3>${local.name} <span style="color:#0ff; font-size:11px;">LVL ${currentLvl}</span></h3>
                <p>${local.desc}</p>
                <div style="font-size:10px; color:#666;">${t('shop_cost_next')}: ${formatNumber(Math.floor(cost * def.costMult))}</div>
            </div>
            <button class="upgrade-btn" 
                id="btn-${key}"
                onmousedown="startBuying('${key}')" 
                onmouseup="stopBuying()" 
                onmouseleave="stopBuying()"
                ontouchstart="startBuying('${key}'); event.preventDefault();" 
                ontouchend="stopBuying(); event.preventDefault();"
            >
                ${formatNumber(cost)}
            </button>
        `;
        grid.appendChild(card);
    });
}

// HOLD TO BUY LOGIC
let holdTimer = null;
let holdSpeed = 500;
let holdStreak = 0;

window.startBuying = function(key) {
    if (holdTimer) return; 
    buyUpgrade(key); 
    holdStreak = 0;
    holdSpeed = 300; 
    
    const loop = () => {
        holdTimer = setTimeout(() => {
            const success = buyUpgrade(key);
            if (success) {
                holdStreak++;
                holdSpeed = Math.max(50, holdSpeed * 0.85); 
                audio.playUpgradeBuy(holdStreak);
                loop();
            } else {
                stopBuying();
            }
        }, holdSpeed);
    };
    loop();
};

window.stopBuying = function() {
    if (holdTimer) { clearTimeout(holdTimer); holdTimer = null; holdStreak = 0; holdSpeed = 300; }
};

window.buyUpgrade = function(key) {
    const def = UPGRADE_defs[key];
    const currentLvl = GameState.upgrades[key];
    const cost = Math.floor(def.baseCost * Math.pow(def.costMult, currentLvl));

    if (GameState.metaCurrency >= cost) {
        GameState.metaCurrency -= cost;
        GameState.upgrades[key]++;
        localStorage.setItem('cyber_rouge_chips', GameState.metaCurrency);
        localStorage.setItem('cyber_rouge_upgrades', JSON.stringify(GameState.upgrades));
        
        document.getElementById('shopCurrency').innerText = formatNumber(GameState.metaCurrency);
        document.getElementById('metaCurrencyMenu').innerText = formatNumber(GameState.metaCurrency);
        
        // Update specific button text
        const nextCost = Math.floor(def.baseCost * Math.pow(def.costMult, currentLvl + 1));
        const btn = document.getElementById(`btn-${key}`);
        if(btn) btn.innerText = `${formatNumber(nextCost)}`;
        
        // Only do full text redraw if slow, for performance
        if(holdSpeed > 100) updateShopUI();
        
        return true;
    } else {
        audio.playSlotHit(0.2); 
        return false;
    }
};

document.getElementById('startBtn').addEventListener('click', () => {
    audio.init();
    document.getElementById('mainMenu').classList.add('hidden');
    document.getElementById('gameUI').classList.remove('hidden');
    
    const startBonus = UPGRADE_defs.startMoney.effect(GameState.upgrades.startMoney);
    GameState.currentMoney = startBonus;
    GameState.maxMoneyInRun = startBonus;
    GameState.secondChanceUsed = false;
    GameState.balls = [];
    GameState.particles = [];
    GameState.active = true;
    GameState.autoEnabled = false;
    
    setBetMode('min');
    initBoard();
    updateUI();
    
    cancelAnimationFrame(animationId);
    animationId = requestAnimationFrame(draw);
});

document.getElementById('shopBtn').addEventListener('click', () => {
    document.getElementById('mainMenu').classList.add('hidden');
    document.getElementById('shopMenu').classList.remove('hidden');
    updateShopUI();
});

document.getElementById('closeShopBtn').addEventListener('click', () => {
    document.getElementById('shopMenu').classList.add('hidden');
    document.getElementById('mainMenu').classList.remove('hidden');
});

document.getElementById('dropBtn').addEventListener('click', (e) => {
    e.stopPropagation(); 
    if(GameState.active) spawnBall(canvas.width / 2 + (Math.random() * 20 - 10), 50);
});

document.getElementById('game-container').addEventListener('mousedown', (e) => {
    // Only spawn if clicking empty canvas space
    if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'INPUT' && GameState.active && document.getElementById('gameUI').classList.contains('hidden') === false) {
        audio.init(); 
        spawnBall(canvas.width / 2 + (Math.random() * 20 - 10), 50);
    }
});

document.getElementById('mainMenuBtn').addEventListener('click', () => {
    document.getElementById('gameOverMenu').classList.add('hidden');
    document.getElementById('gameOverMenu').classList.remove('system-failure'); 
    document.getElementById('mainMenu').classList.remove('hidden');
    document.getElementById('metaCurrencyMenu').innerText = formatNumber(GameState.metaCurrency);
    cancelAnimationFrame(animationId);
});

window.addEventListener('resize', resize);
resize();
updateLanguage(); // Init Text
audio.enabled = GameState.settings.audio; // Sync audio state
document.getElementById('metaCurrencyMenu').innerText = formatNumber(GameState.metaCurrency);

</script>
</body>
</html>
