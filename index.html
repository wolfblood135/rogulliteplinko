<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Plinko: Cyber Rogue</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;600;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap'); /* Terminal font */

        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            color: #fff;
            font-family: 'Rajdhani', sans-serif;
            overflow: hidden;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 600px;
            background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%);
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.1);
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlays */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        .currency-box {
            text-align: left;
        }

        .currency-label {
            font-size: 14px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .currency-value {
            font-size: 32px;
            font-weight: 700;
            color: #0ff;
        }

        .meta-currency-value {
            color: #f0f;
        }

        .hud-bottom {
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        /* Bet Controls */
        .bet-controls {
            display: flex;
            gap: 5px;
            width: 100%;
            max-width: 300px;
            justify-content: center;
            margin-bottom: 5px;
        }

        .btn-sm {
            flex: 1;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid #444;
            color: #888;
            padding: 8px 0;
            font-size: 14px;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 4px;
        }

        .btn-sm:hover {
            border-color: #0ff;
            color: #0ff;
        }

        .btn-sm.active {
            background: rgba(0, 255, 255, 0.2);
            border-color: #0ff;
            color: #0ff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
        }

        .btn {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #0ff;
            color: #0ff;
            padding: 15px 40px;
            font-size: 20px;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 700;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.2s;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
            border-radius: 4px;
        }

        .btn:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.6);
            transform: scale(1.05);
        }

        .btn:active {
            transform: scale(0.95);
        }

        .btn-bet {
            width: 100%;
            max-width: 300px;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.1), transparent);
        }
        
        /* Cash Out Button Style */
        .btn-cashout {
            margin-top: 10px;
            width: 100%;
            max-width: 300px;
            background: rgba(255, 100, 0, 0.15);
            border: 2px solid #ff6600;
            color: #ff6600;
            padding: 10px 20px;
            font-size: 16px;
        }
        
        .btn-cashout:hover {
            background: #ff6600;
            color: #000;
            box-shadow: 0 0 20px rgba(255, 100, 0, 0.6);
        }

        .btn-shop {
            border-color: #f0f;
            color: #f0f;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.2);
        }
        .btn-shop:hover {
            background: #f0f;
            color: #000;
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.6);
        }

        /* Menus */
        .menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
            opacity: 1;
            transition: opacity 0.3s;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            font-size: 48px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 5px;
            margin-bottom: 10px;
            text-align: center;
        }
        
        h1 span { color: #0ff; }
        h1 span.rouge { color: #f0f; }

        .shop-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            width: 80%;
            max-width: 400px;
            margin-bottom: 20px;
            max-height: 60vh;
            overflow-y: auto;
        }

        .upgrade-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #444;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 5px;
            transition: 0.2s;
        }

        .upgrade-card:hover {
            border-color: #f0f;
            background: rgba(255, 0, 255, 0.05);
        }

        .upgrade-info h3 { margin: 0; font-size: 18px; color: #fff; }
        .upgrade-info p { margin: 5px 0 0; font-size: 12px; color: #888; }
        
        .upgrade-btn {
            background: transparent;
            border: 1px solid #f0f;
            color: #f0f;
            padding: 5px 15px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-weight: bold;
            min-width: 80px;
        }
        
        .upgrade-btn:disabled {
            border-color: #444;
            color: #444;
            cursor: not-allowed;
        }

        .upgrade-btn:not(:disabled):hover {
            background: #f0f;
            color: white;
        }

        .floating-text {
            position: absolute;
            font-weight: bold;
            pointer-events: none;
            animation: floatUp 1s forwards ease-out;
            text-shadow: 0 0 5px currentColor;
        }

        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.5); opacity: 0; }
        }
        
        .tutorial {
            font-size: 12px;
            color: #666;
            margin-top: 20px;
            text-align: center;
        }

        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
            70% { box-shadow: 0 0 0 50px rgba(255, 0, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
        }
        
        .system-failure {
            animation: pulse-red 2s infinite;
        }

        .counting-val {
            font-variant-numeric: tabular-nums;
        }

        .btn-ai {
            margin-top: 5px;
            background: rgba(0, 20, 0, 0.8);
            border: 1px solid #0f0;
            color: #0f0;
            padding: 4px 10px;
            font-size: 12px;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 700;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.2);
            pointer-events: auto;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: all 0.2s;
        }
        .btn-ai:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.6);
        }
        .btn-ai:disabled {
            opacity: 0.5;
            cursor: wait;
        }

        .ai-terminal {
            position: absolute;
            bottom: 200px; /* Moved up for new button */
            left: 50%;
            transform: translateX(-50%);
            width: 85%;
            max-width: 400px;
            background: rgba(0, 10, 0, 0.95);
            border: 1px solid #0f0;
            padding: 15px;
            border-radius: 2px;
            font-family: 'VT323', monospace;
            color: #0f0;
            font-size: 18px;
            line-height: 1.2;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.1);
            display: none;
            z-index: 50;
            pointer-events: none;
            text-shadow: 0 0 2px #0f0;
        }

        .ai-terminal.active {
            display: block;
            animation: termFadeIn 0.3s ease-out;
        }

        .ai-header {
            font-size: 12px;
            color: #005500;
            border-bottom: 1px solid #005500;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
        }

        .typing-cursor::after {
            content: '█';
            animation: blink 1s infinite;
            margin-left: 2px;
        }

        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }
        @keyframes termFadeIn { from { opacity: 0; transform: translateX(-50%) translateY(10px); } to { opacity: 1; transform: translateX(-50%) translateY(0); } }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <!-- Game HUD -->
    <div id="gameUI" class="ui-layer hidden">
        <div class="hud-top">
            <div class="currency-box">
                <div class="currency-label">Run Bakiyesi</div>
                <div class="currency-value" id="currentMoneyDisplay">$100</div>
            </div>
            <div class="currency-box" style="text-align: right; display: flex; flex-direction: column; align-items: flex-end;">
                <div class="currency-label">Max Skor</div>
                <div class="currency-value" id="maxMoneyDisplay" style="color: #ff0; font-size: 24px;">$100</div>
                <button class="btn-ai" id="aiBtn" onclick="triggerAIAnalysis()">
                    <span>✨</span> AI ANALİZİ
                </button>
            </div>
        </div>
        
        <div id="aiTerminal" class="ai-terminal">
            <div class="ai-header">
                <span>SYSTEM: GHOST_AI.exe</span>
                <span>STATUS: CONNECTED</span>
            </div>
            <div id="aiContent"></div>
        </div>
        
        <div class="hud-bottom">
            <div class="bet-controls">
                <button class="btn-sm" onclick="setBetMode('min')">MIN</button>
                <button class="btn-sm" onclick="setBetMode(0.10)">%10</button>
                <button class="btn-sm" onclick="setBetMode(0.25)">%25</button>
                <button class="btn-sm" onclick="setBetMode(0.50)">%50</button>
                <button class="btn-sm" onclick="setBetMode(1.0)">MAX</button>
            </div>
            
            <div style="font-size: 14px; color: #aaa; margin-bottom: 5px;">TOP BEDELİ: $<span id="betCostDisplay">10</span></div>
            <button class="btn btn-bet" id="dropBtn">TOP BIRAK</button>
            
            <!-- NEW CASH OUT BUTTON -->
            <button class="btn btn-cashout" id="cashOutBtn" onclick="finishRunManually()">
                RUN'I BİTİR (+0 ÇİP)
            </button>
            <div style="font-size: 10px; color: #666; margin-top: 2px;">KUR: $1000 = 1 ÇİP</div>
        </div>
    </div>

    <!-- Main Menu -->
    <div id="mainMenu" class="menu-overlay">
        <h1>NEON<span>PLINKO</span><br><span class="rouge">ROGUELITE</span></h1>
        <div style="margin-bottom: 30px; text-align: center;">
            <div class="currency-label">CYBER ÇİPLERİN</div>
            <div class="currency-value meta-currency-value" id="metaCurrencyMenu">0</div>
        </div>
        <button class="btn" id="startBtn">RUN'A BAŞLA</button>
        <br>
        <button class="btn btn-shop" id="shopBtn">MARKET & YÜKSELTMELER</button>
        <div class="tutorial">Tıklayarak sesi açın ve oyuna başlayın.<br>Ekranın herhangi bir yerine tıklayarak da top bırakabilirsiniz.</div>
    </div>

    <!-- Shop Menu -->
    <div id="shopMenu" class="menu-overlay hidden">
        <h1>SİBER <span>MARKET</span></h1>
        <div style="margin-bottom: 20px;">
            <span class="currency-label">BAKİYE: </span>
            <span class="currency-value meta-currency-value" id="shopCurrency">0</span>
        </div>
        
        <div class="shop-grid" id="shopGrid">
            <!-- Upgrades will be injected here via JS -->
        </div>

        <button class="btn" id="closeShopBtn">GERİ DÖN</button>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverMenu" class="menu-overlay hidden">
        <h1 style="color: #ff4444;" class="system-failure-text" id="goTitle">SİSTEM <span>ÇÖKTÜ</span></h1>
        <div style="text-align: center; margin-bottom: 20px;">
            <p style="color: #aaa; margin: 5px;">TOPLANAN NAKİT</p>
            <div class="currency-value counting-val" id="goMaxMoney" style="color: #fff;">$0</div>
            <p style="color: #aaa; margin: 15px 0 5px 0;">KAZANILAN CYBER ÇİP</p>
            <div class="currency-value meta-currency-value counting-val" id="goMetaGain">+0</div>
        </div>
        <button class="btn btn-bet" id="restartBtn" style="display: none;">İKİNCİ ŞANS KULLAN</button>
        <br id="spacer" style="display: none;">
        <button class="btn" id="mainMenuBtn">ANA MENÜ</button>
    </div>

</div>

<script>
/**
 * AUDIO SYSTEM
 */
class SoundManager {
    constructor() {
        this.ctx = null;
        this.enabled = false;
    }

    init() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.enabled = true;
        } else if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    }

    playTone(freq, type, duration, vol = 0.1) {
        if (!this.enabled) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }

    playPegHit() {
        this.playTone(800 + Math.random() * 200, 'sine', 0.1, 0.05);
    }

    playSpawn() {
        this.playTone(200, 'triangle', 0.1, 0.1);
    }

    playSlotHit(multiplier) {
        if (multiplier < 1) {
            this.playTone(150, 'sawtooth', 0.3, 0.1);
        } else if (multiplier < 4) {
            this.playTone(440, 'sine', 0.4, 0.1);
            setTimeout(() => this.playTone(554, 'sine', 0.4, 0.1), 50);
        } else {
            this.playTone(440, 'square', 0.1, 0.1);
            setTimeout(() => this.playTone(554, 'square', 0.1, 0.1), 100);
            setTimeout(() => this.playTone(659, 'square', 0.1, 0.1), 200);
            setTimeout(() => this.playTone(880, 'square', 0.6, 0.2), 300);
        }
    }

    playTypingSound() {
        if (!this.enabled) return;
        this.playTone(800 + Math.random() * 400, 'square', 0.05, 0.02);
    }
    
    playExplosion() {
        if (!this.enabled) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.frequency.setValueAtTime(100, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.5);
    }

    playGameOver() {
        if (!this.enabled) return;
        this.playTone(300, 'sawtooth', 0.5, 0.2); 
        setTimeout(() => this.playTone(250, 'sawtooth', 0.5, 0.2), 400); 
        setTimeout(() => this.playTone(200, 'sawtooth', 0.5, 0.2), 800); 
        setTimeout(() => this.playTone(100, 'square', 1.5, 0.3), 1200); 
    }
    
    playCashOut() {
        if (!this.enabled) return;
        this.playTone(600, 'sine', 0.1, 0.1);
        setTimeout(() => this.playTone(800, 'sine', 0.1, 0.1), 100);
        setTimeout(() => this.playTone(1200, 'square', 0.4, 0.2), 200);
    }
}

const audio = new SoundManager();

/**
 * GAME CONSTANTS & CONFIG
 */
const CONFIG = {
    gravity: 0.25,
    friction: 0.99,
    restitution: 0.6,
    pegRadius: 4,
    ballRadius: 7,
    rows: 14,
    pegSpacingX: 35,
    pegSpacingY: 35
};

const ECONOMY = {
    conversionRate: 1000 // $1000 = 1 Chip
};

/**
 * GAME STATE
 */
const GameState = {
    metaCurrency: parseInt(localStorage.getItem('cyber_rouge_chips') || '0'),
    
    upgrades: JSON.parse(localStorage.getItem('cyber_rouge_upgrades') || JSON.stringify({
        startMoney: 0,
        multipliers: 0,
        secondChance: 0
    })),

    currentMoney: 100,
    maxMoneyInRun: 100,
    betCost: 10,
    betMode: 'min', 
    secondChanceUsed: false,
    balls: [],
    particles: [],
    screenShake: 0,
    active: false
};

const UPGRADE_defs = {
    startMoney: {
        name: "Yatırım Fonu",
        desc: "Oyuna daha fazla parayla başla.",
        baseCost: 50,
        costMult: 1.5,
        maxLevel: 10,
        effect: (lvl) => 100 + (lvl * 50)
    },
    multipliers: {
        name: "Hack Modülü",
        desc: "Kenar çarpanlarını artırır.",
        baseCost: 100,
        costMult: 2.0,
        maxLevel: 5,
        effect: (lvl) => lvl 
    },
    secondChance: {
        name: "Acil Durum Protokolü",
        desc: "İflas ettiğinde max paranın %25'i ile bir kere diril.",
        baseCost: 500,
        costMult: 100,
        maxLevel: 1,
        effect: (lvl) => lvl === 1
    }
};

/**
 * GEMINI AI INTEGRATION
 */
const apiKey = ""; 

async function triggerAIAnalysis() {
    if (!apiKey) {
        showTerminalMessage("HATA: API Anahtarı Bulunamadı.");
        return;
    }

    const btn = document.getElementById('aiBtn');
    btn.disabled = true;
    btn.innerHTML = `<span>⏳</span> BAĞLANIYOR...`;
    
    showTerminalMessage("VERİ ANALİZ EDİLİYOR...", true);

    const prompt = `
        Rolün: Cyberpunk temalı bir Plinko oyununda oyuncuya eşlik eden 'Ghost' isimli, biraz alaycı ve cool bir yapay zekasın.
        
        Oyun Durumu:
        - Mevcut Para: ${Math.floor(GameState.currentMoney)}
        - Bu Turdaki Max Para: ${Math.floor(GameState.maxMoneyInRun)}
        - Bahis Modu: ${GameState.betMode === 1.0 ? "MAX (All-in)" : GameState.betMode}
        - Yükseltmeler: ${JSON.stringify(GameState.upgrades)}
        
        Görevin: Oyuncuya duruma uygun, kısa (maksimum 20 kelime), atmosferik, siberpunk jargonlu, Türkçe bir yorum yap. 
        Eğer parası azsa dalga geç, çoksa gaza getir, çok risk alıyorsa uyar.
        Sadece yorumu yaz, tırnak işareti kullanma.
    `;

    try {
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                contents: [{ parts: [{ text: prompt }] }]
            })
        });

        if (!response.ok) throw new Error('Network response was not ok');

        const data = await response.json();
        const aiText = data.candidates[0].content.parts[0].text;
        
        showTerminalMessage(aiText);
        
    } catch (error) {
        console.error("AI Error:", error);
        showTerminalMessage("BAĞLANTI HATASI: GHOST ÇEVRİMDIŞI.");
    } finally {
        btn.disabled = false;
        btn.innerHTML = `<span>✨</span> AI ANALİZİ`;
    }
}

let typeWriterTimeout;
function showTerminalMessage(text, isLoading = false) {
    const term = document.getElementById('aiTerminal');
    const content = document.getElementById('aiContent');
    
    term.classList.add('active');
    term.style.display = 'block';
    content.innerHTML = '';
    content.classList.add('typing-cursor');

    if (typeWriterTimeout) clearTimeout(typeWriterTimeout);

    let i = 0;
    const speed = 30; 

    function typeWriter() {
        if (i < text.length) {
            content.innerHTML += text.charAt(i);
            i++;
            if (i % 3 === 0) audio.playTypingSound(); 
            typeWriterTimeout = setTimeout(typeWriter, speed);
        } else {
            content.classList.remove('typing-cursor');
            if (!isLoading) {
                setTimeout(() => {
                    term.classList.remove('active');
                    setTimeout(() => term.style.display = 'none', 300);
                }, 5000); 
            }
        }
    }
    typeWriter();
}

/**
 * PHYSICS CLASSES
 */
class Vector {
    constructor(x, y) { this.x = x; this.y = y; }
}

class Particle {
    constructor(x, y, color, speed) {
        this.x = x;
        this.y = y;
        this.color = color;
        const angle = Math.random() * Math.PI * 2;
        const vel = Math.random() * speed;
        this.vx = Math.cos(angle) * vel;
        this.vy = Math.sin(angle) * vel;
        this.life = 1.0;
        this.decay = 0.02 + Math.random() * 0.03;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= this.decay;
    }

    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}

class Ball {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 1;
        this.vy = 0;
        this.radius = CONFIG.ballRadius;
        this.color = `hsl(${Math.random() * 60 + 160}, 100%, 50%)`;
        this.trail = [];
        this.active = true;
    }

    update(pegs, buckets) {
        this.vy += CONFIG.gravity;
        this.vx *= CONFIG.friction;
        this.vy *= CONFIG.friction;
        this.x += this.vx;
        this.y += this.vy;

        const canvasWidth = document.getElementById('gameCanvas').width;
        if (this.x < this.radius) {
            this.x = this.radius;
            this.vx *= -0.5;
        } else if (this.x > canvasWidth - this.radius) {
            this.x = canvasWidth - this.radius;
            this.vx *= -0.5;
        }

        this.trail.push({x: this.x, y: this.y});
        if (this.trail.length > 10) this.trail.shift();

        for (let peg of pegs) {
            const dx = this.x - peg.x;
            const dy = this.y - peg.y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            if (dist < this.radius + CONFIG.pegRadius) {
                const angle = Math.atan2(dy, dx);
                
                const centerX = canvasWidth / 2;
                const isLeftOfCenter = this.x < centerX;
                const directionToCenter = isLeftOfCenter ? 1 : -1;

                const biasStrength = 0.8; 
                let rigBias = 0;

                if (Math.random() < 0.6) {
                    rigBias = directionToCenter * biasStrength;
                } else if (Math.random() < 0.1) {
                    rigBias = -directionToCenter * (biasStrength * 1.5);
                    peg.pulse = 2.0; 
                }

                const overlap = (this.radius + CONFIG.pegRadius) - dist;
                this.x += Math.cos(angle) * overlap;
                this.y += Math.sin(angle) * overlap;

                this.vx += Math.cos(angle) * 2 + rigBias; 
                this.vy *= -0.5;
                
                audio.playPegHit();
                if(peg.pulse < 1) peg.pulse = 1.0; 
                
                this.vx += (Math.random() - 0.5) * 0.5;
            }
        }

        if (this.y > buckets[0].y) {
            const bucketWidth = CONFIG.pegSpacingX;
            const centerX = canvasWidth / 2;
            const totalBuckets = buckets.length;
            const startX = centerX - (totalBuckets * bucketWidth) / 2;
            
            let col = Math.floor((this.x - startX) / bucketWidth);
            
            if (col < 0) col = 0;
            if (col >= totalBuckets) col = totalBuckets - 1;

            const bucket = buckets[col];
            if (bucket) {
                this.finish(bucket.multiplier, bucket.color);
                return;
            }
        }
    }

    finish(multiplier, color) {
        this.active = false;
        
        let winBase = this.cost || GameState.betCost;
        const winAmount = Math.floor(winBase * multiplier);
        GameState.currentMoney += winAmount;
        
        if (GameState.currentMoney > GameState.maxMoneyInRun) {
            GameState.maxMoneyInRun = GameState.currentMoney;
        }

        updateUI();
        
        audio.playSlotHit(multiplier);
        createExplosion(this.x, this.y, color, multiplier > 3 ? 30 : 10);
        showFloatingText(this.x, this.y - 30, `+$${winAmount}`, multiplier > 1 ? '#0f0' : '#888');
        
        if (multiplier >= 10) {
            GameState.screenShake = 20;
            const flash = document.createElement('div');
            flash.style.cssText = "position:absolute;top:0;left:0;width:100%;height:100%;background:white;opacity:0.5;pointer-events:none;z-index:999;";
            document.body.appendChild(flash);
            setTimeout(() => flash.remove(), 100);
        } else if (multiplier > 1) {
            GameState.screenShake = 5;
        }

        // Removed checkGameOver here, it happens in draw loop
    }

    draw(ctx) {
        ctx.beginPath();
        for(let i=0; i<this.trail.length; i++) {
            const p = this.trail[i];
            ctx.lineTo(p.x, p.y);
        }
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.5;
        ctx.stroke();
        ctx.globalAlpha = 1;

        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = "#fff";
        ctx.fill();
        
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.shadowBlur = 0;
    }
}

/**
 * GAME ENGINE & LOGIC
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let pegs = [];
let buckets = [];
let animationId;

function resize() {
    canvas.width = document.getElementById('game-container').offsetWidth;
    canvas.height = document.getElementById('game-container').offsetHeight;
    initBoard();
}

function initBoard() {
    pegs = [];
    buckets = [];
    
    const startY = 100;
    const centerX = canvas.width / 2;
    
    for (let row = 0; row < CONFIG.rows; row++) {
        const cols = row + 3;
        const width = (cols - 1) * CONFIG.pegSpacingX;
        const startX = centerX - width / 2;

        for (let col = 0; col < cols; col++) {
            pegs.push({
                x: startX + col * CONFIG.pegSpacingX,
                y: startY + row * CONFIG.pegSpacingY,
                pulse: 0
            });
        }
    }

    const lastRowY = startY + (CONFIG.rows - 1) * CONFIG.pegSpacingY;
    const bucketY = lastRowY + 40;
    const bucketWidth = CONFIG.pegSpacingX;
    const totalBuckets = CONFIG.rows + 2; 
    const startX = centerX - ((totalBuckets) * bucketWidth) / 2;

    let mults = [];
    const centerIndex = Math.floor(totalBuckets / 2); // ~8
    const bonus = GameState.upgrades.multipliers * 0.2; 
    
    // HARDCORE MODE MULTIPLIERS (As requested)
    // 16 buckets. 
    // Indices: 0, 15 -> 25x
    // Indices: 1, 14 -> 5x
    // Indices: 2, 13 -> 2x
    // Indices: 3, 12 -> 1x
    // Others -> 0.2x (Loss)
    
    for(let i=0; i<totalBuckets; i++) {
        let dist = Math.abs(i - (totalBuckets - 1) / 2); // Exact center distance
        
        let val = 0.2; // Default loss
        
        // Map to integer indices for symmetry check from edges
        // 0 and 15 are edges
        if (i === 0 || i === totalBuckets - 1) {
            val = 25.0 + (bonus * 5); // EDGE: 25x
        } else if (i === 1 || i === totalBuckets - 2) {
            val = 5.0 + bonus; // 5x
        } else if (i === 2 || i === totalBuckets - 3) {
            val = 2.0 + bonus; // 2x
        } else if (i === 3 || i === totalBuckets - 4) {
            val = 1.0; // 1x (Safe)
        } else {
            val = 0.2; // Loss zone
        }

        mults.push(val);
    }

    for (let i = 0; i < totalBuckets; i++) {
        let val = mults[i];
        let color = '#fff';
        if (val < 1) color = '#f00'; 
        else if (val < 2) color = '#888'; // 1x is neutral
        else if (val < 5) color = '#aa0'; 
        else if (val < 10) color = '#0f0'; 
        else color = '#f0f'; 

        buckets.push({
            x: startX + i * bucketWidth,
            y: bucketY,
            width: bucketWidth - 4, // Visual width
            height: 30,
            multiplier: val,
            color: color
        });
    }
}

function createExplosion(x, y, color, count) {
    for (let i = 0; i < count; i++) {
        GameState.particles.push(new Particle(x, y, color, 5));
    }
}

function showFloatingText(x, y, text, color) {
    const el = document.createElement('div');
    el.className = 'floating-text';
    el.innerText = text;
    el.style.left = x + 'px';
    el.style.top = y + 'px';
    el.style.color = color;
    document.getElementById('game-container').appendChild(el);
    setTimeout(() => el.remove(), 1000);
}

function spawnBall(x, y) {
    calculateBetCost();

    if (GameState.betMode === 'min' && GameState.currentMoney < 10 && GameState.currentMoney > 0) {
        GameState.betCost = GameState.currentMoney;
    }
    
    if (GameState.betCost < 1 && GameState.currentMoney >= 1) {
        GameState.betCost = 1;
    }

    const ballCost = GameState.betCost;

    if (GameState.currentMoney >= ballCost && ballCost > 0) {
        GameState.currentMoney -= ballCost;
        updateUI(); 
        
        const b = new Ball(x, y);
        b.cost = ballCost; 
        GameState.balls.push(b);
        
        audio.playSpawn();
    } else {
        document.getElementById('currentMoneyDisplay').style.color = 'red';
        setTimeout(()=> document.getElementById('currentMoneyDisplay').style.color = '#0ff', 200);
    }
}

function calculateBetCost() {
    if (typeof GameState.betMode === 'string') {
        GameState.betCost = 10;
    } else {
        let cost = Math.floor(GameState.currentMoney * GameState.betMode);
        if (cost < 1 && GameState.currentMoney >= 1) cost = 1;
        if (GameState.betMode === 1.0) cost = GameState.currentMoney;
        GameState.betCost = cost;
    }
}

function checkGameOver() {
    if (GameState.balls.length === 0 && GameState.currentMoney < 1) {
        if (GameState.upgrades.secondChance === 1 && !GameState.secondChanceUsed) {
            triggerSecondChance();
            return;
        }

        setTimeout(() => {
            endRun(false);
        }, 1000);
    }
}

function triggerSecondChance() {
    GameState.active = false; 
    const reviveAmount = Math.floor(GameState.maxMoneyInRun * 0.25);
    
    const div = document.createElement('div');
    div.style.cssText = "position:absolute; top:40%; left:10%; width:80%; background:black; border:2px solid #f0f; padding:20px; text-align:center; z-index:500; color:#fff;";
    div.innerHTML = `<h2 style="color:#f0f">SİSTEM HATASI ALGILANDI</h2><p>Acil Durum Protokolü devrede...</p><h1 style="color:#0ff">+$${reviveAmount}</h1>`;
    document.getElementById('game-container').appendChild(div);

    setTimeout(() => {
        GameState.currentMoney = reviveAmount;
        GameState.secondChanceUsed = true;
        GameState.active = true;
        updateUI();
        div.remove();
        audio.playExplosion();
    }, 2000);
}

// Manual Cash Out
window.finishRunManually = function() {
    if (!GameState.active || GameState.balls.length > 0) {
        // Prevent accidental clicks if balls are falling or game inactive
        if(GameState.balls.length > 0) {
            showFloatingText(window.innerWidth/2, window.innerHeight/2, "BEKLE...", "red");
            return;
        }
    }
    
    endRun(true);
};

// Animation helper
function animateValue(id, start, end, duration, prefix = "", suffix = "") {
    const obj = document.getElementById(id);
    let startTimestamp = null;
    const step = (timestamp) => {
        if (!startTimestamp) startTimestamp = timestamp;
        const progress = Math.min((timestamp - startTimestamp) / duration, 1);
        const val = Math.floor(progress * (end - start) + start);
        obj.innerHTML = prefix + val + suffix;
        
        if (progress < 1.0 && Math.random() < 0.2) {
             audio.playTone(800 + (progress * 500), 'triangle', 0.05, 0.02);
        }
        
        if (progress < 1) {
            window.requestAnimationFrame(step);
        }
    };
    window.requestAnimationFrame(step);
}

function endRun(isManual = false) {
    GameState.active = false;
    
    // Reward Calculation
    let reward = 0;
    let endMoney = 0;
    
    if (isManual) {
        // Cash Out Logic
        audio.playCashOut();
        endMoney = GameState.currentMoney;
        reward = Math.floor(GameState.currentMoney / ECONOMY.conversionRate);
        document.getElementById('goTitle').innerHTML = "RUN <span>TAMAMLANDI</span>";
        document.getElementById('goTitle').style.color = "#0f0";
    } else {
        // Bankruptcy Logic (Old logic based on max money reached)
        audio.playGameOver();
        endMoney = GameState.maxMoneyInRun;
        reward = Math.floor(GameState.maxMoneyInRun * 0.10); // 10% pity
        // Cap pity reward to avoid exploit
        if(reward > 10) reward = 10; 
        
        document.getElementById('goTitle').innerHTML = "SİSTEM <span>ÇÖKTÜ</span>";
        document.getElementById('goTitle').style.color = "#ff4444";
    }

    GameState.metaCurrency += reward;
    localStorage.setItem('cyber_rouge_chips', GameState.metaCurrency);

    const goMenu = document.getElementById('gameOverMenu');
    document.getElementById('gameUI').classList.add('hidden');
    goMenu.classList.remove('hidden');
    
    if(!isManual) goMenu.classList.add('system-failure'); 
    else goMenu.classList.remove('system-failure');

    document.getElementById('goMaxMoney').innerText = "$0";
    document.getElementById('goMetaGain').innerText = "+0 ÇİP";

    setTimeout(() => {
        animateValue("goMaxMoney", 0, endMoney, 1500, "$");
    }, 500);

    setTimeout(() => {
        animateValue("goMetaGain", 0, reward, 1500, "+", " ÇİP");
        createExplosion(window.innerWidth/2, window.innerHeight/2, isManual ? '#0f0' : '#f0f', 50);
    }, 2000);
}

/**
 * RENDERING
 */
function draw() {
    // Background with slight red tint if game over active and FAILED
    const goMenu = document.getElementById('gameOverMenu');
    if (!GameState.active && !goMenu.classList.contains('hidden')) {
         if (goMenu.classList.contains('system-failure')) {
             ctx.fillStyle = '#100000'; // Fail
         } else {
             ctx.fillStyle = '#001000'; // Success (Cash Out)
         }
    } else {
         ctx.fillStyle = '#050505';
    }
    
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    let shakeX = 0, shakeY = 0;
    if (GameState.screenShake > 0) {
        shakeX = (Math.random() - 0.5) * GameState.screenShake;
        shakeY = (Math.random() - 0.5) * GameState.screenShake;
        GameState.screenShake *= 0.9;
        if(GameState.screenShake < 0.5) GameState.screenShake = 0;
    }

    ctx.save();
    ctx.translate(shakeX, shakeY);

    for (let peg of pegs) {
        ctx.beginPath();
        ctx.arc(peg.x, peg.y, CONFIG.pegRadius, 0, Math.PI * 2);
        
        if (peg.pulse > 0.01) {
            ctx.fillStyle = `rgba(255, 255, 255, ${peg.pulse})`;
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#fff';
            peg.pulse *= 0.9;
        } else {
            ctx.fillStyle = '#333';
            ctx.shadowBlur = 0;
        }
        
        ctx.fill();
        ctx.shadowBlur = 0;
    }

    for (let b of buckets) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
        ctx.fillRect(b.x, b.y, b.width, b.height);
        
        ctx.font = 'bold 12px Rajdhani';
        ctx.textAlign = 'center';
        ctx.fillStyle = b.color;
        ctx.fillText(`${b.multiplier}x`, b.x + b.width/2, b.y + 20);
        
        ctx.fillStyle = b.color;
        ctx.fillRect(b.x, b.y + b.height - 2, b.width, 2);
    }

    for (let i = GameState.balls.length - 1; i >= 0; i--) {
        let ball = GameState.balls[i];
        if (ball.active) {
            ball.update(pegs, buckets);
            ball.draw(ctx);
        } else {
            GameState.balls.splice(i, 1);
            checkGameOver();
        }
    }

    for (let i = GameState.particles.length - 1; i >= 0; i--) {
        let p = GameState.particles[i];
        p.update();
        p.draw(ctx);
        if (p.life <= 0) GameState.particles.splice(i, 1);
    }

    ctx.restore();

    animationId = requestAnimationFrame(draw);
}

/**
 * UI & INTERACTION
 */
function updateUI() {
    document.getElementById('currentMoneyDisplay').innerText = `$${Math.floor(GameState.currentMoney)}`;
    document.getElementById('maxMoneyDisplay').innerText = `$${Math.floor(GameState.maxMoneyInRun)}`;
    
    calculateBetCost();
    document.getElementById('betCostDisplay').innerText = GameState.betCost;

    const btn = document.getElementById('dropBtn');
    const cashBtn = document.getElementById('cashOutBtn');
    
    // Update Cash Out Button Text
    const potentialChips = Math.floor(GameState.currentMoney / ECONOMY.conversionRate);
    cashBtn.innerText = `RUN'I BİTİR (+${potentialChips} ÇİP)`;

    if (GameState.currentMoney < GameState.betCost && GameState.betMode !== 'min' && GameState.currentMoney > 0) {
         btn.style.borderColor = 'red';
         btn.style.opacity = 0.5;
    } else if (GameState.currentMoney <= 0) {
        btn.style.borderColor = 'red';
        btn.style.opacity = 0.5;
        // Also disable cashout if broke
        cashBtn.style.opacity = 0.5;
        cashBtn.style.pointerEvents = 'none';
    } else {
        btn.style.borderColor = '#0ff';
        btn.style.opacity = 1;
        cashBtn.style.opacity = 1;
        cashBtn.style.pointerEvents = 'auto';
    }
}

window.setBetMode = function(mode) {
    GameState.betMode = mode;
    
    document.querySelectorAll('.btn-sm').forEach(btn => {
        btn.classList.remove('active');
        if (mode === 'min' && btn.innerText === 'MIN') btn.classList.add('active');
        if (mode === 0.10 && btn.innerText === '%10') btn.classList.add('active');
        if (mode === 0.25 && btn.innerText === '%25') btn.classList.add('active');
        if (mode === 0.50 && btn.innerText === '%50') btn.classList.add('active');
        if (mode === 1.0 && btn.innerText === 'MAX') btn.classList.add('active');
    });

    updateUI();
};

function updateShopUI() {
    document.getElementById('shopCurrency').innerText = GameState.metaCurrency;
    const grid = document.getElementById('shopGrid');
    grid.innerHTML = '';

    Object.keys(UPGRADE_defs).forEach(key => {
        const def = UPGRADE_defs[key];
        const currentLvl = GameState.upgrades[key];
        const isMax = currentLvl >= def.maxLevel;
        
        let cost = Math.floor(def.baseCost * Math.pow(def.costMult, currentLvl));
        
        const card = document.createElement('div');
        card.className = 'upgrade-card';
        card.innerHTML = `
            <div class="upgrade-info">
                <h3>${def.name} <span style="color:#0ff; font-size:12px;">LVL ${currentLvl}</span></h3>
                <p>${def.desc}</p>
            </div>
            <button class="upgrade-btn" ${isMax ? 'disabled' : ''} onclick="buyUpgrade('${key}', ${cost})">
                ${isMax ? 'MAX' : '$' + cost}
            </button>
        `;
        grid.appendChild(card);
    });
}

window.buyUpgrade = function(key, cost) {
    if (GameState.metaCurrency >= cost) {
        GameState.metaCurrency -= cost;
        GameState.upgrades[key]++;
        localStorage.setItem('cyber_rouge_chips', GameState.metaCurrency);
        localStorage.setItem('cyber_rouge_upgrades', JSON.stringify(GameState.upgrades));
        audio.playSlotHit(10); 
        updateShopUI();
        document.getElementById('metaCurrencyMenu').innerText = GameState.metaCurrency;
    } else {
        audio.playSlotHit(0.2); 
    }
};

document.getElementById('startBtn').addEventListener('click', () => {
    audio.init();
    document.getElementById('mainMenu').classList.add('hidden');
    document.getElementById('gameUI').classList.remove('hidden');
    
    const startBonus = UPGRADE_defs.startMoney.effect(GameState.upgrades.startMoney);
    GameState.currentMoney = startBonus;
    GameState.maxMoneyInRun = startBonus;
    GameState.secondChanceUsed = false;
    GameState.balls = [];
    GameState.particles = [];
    GameState.active = true;
    
    setBetMode('min');

    initBoard();
    updateUI();
    draw();
});

document.getElementById('shopBtn').addEventListener('click', () => {
    document.getElementById('mainMenu').classList.add('hidden');
    document.getElementById('shopMenu').classList.remove('hidden');
    updateShopUI();
});

document.getElementById('closeShopBtn').addEventListener('click', () => {
    document.getElementById('shopMenu').classList.add('hidden');
    document.getElementById('mainMenu').classList.remove('hidden');
});

document.getElementById('dropBtn').addEventListener('click', (e) => {
    e.stopPropagation(); 
    if(GameState.active) spawnBall(canvas.width / 2 + (Math.random() * 20 - 10), 50);
});

document.getElementById('game-container').addEventListener('mousedown', (e) => {
    if (e.target.tagName !== 'BUTTON' && GameState.active && document.getElementById('gameUI').classList.contains('hidden') === false) {
        audio.init(); 
        spawnBall(canvas.width / 2 + (Math.random() * 20 - 10), 50);
    }
});

document.getElementById('mainMenuBtn').addEventListener('click', () => {
    document.getElementById('gameOverMenu').classList.add('hidden');
    document.getElementById('gameOverMenu').classList.remove('system-failure'); 
    document.getElementById('mainMenu').classList.remove('hidden');
    document.getElementById('metaCurrencyMenu').innerText = GameState.metaCurrency;
    cancelAnimationFrame(animationId);
});

window.addEventListener('resize', resize);
resize();
document.getElementById('metaCurrencyMenu').innerText = GameState.metaCurrency;

</script>
</body>
</html>
